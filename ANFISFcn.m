function [output, state] = ANFISFcn(input, params, varargin)
%ANFISFCN Function implementing an imported ONNX network.
%
% THIS FILE WAS AUTO-GENERATED BY importONNXFunction.
% ONNX Operator Set Version: 10
%
% Variable names in this function are taken from the original ONNX file.
%
% [OUTPUT] = ANFISFcn(INPUT, PARAMS)
%			- Evaluates the imported ONNX network ANFISFCN with input(s)
%			INPUT and the imported network parameters in PARAMS. Returns
%			network output(s) in OUTPUT.
%
% [OUTPUT, STATE] = ANFISFcn(INPUT, PARAMS)
%			- Additionally returns state variables in STATE. When training,
%			use this form and set TRAINING to true.
%
% [__] = ANFISFcn(INPUT, PARAMS, 'NAME1', VAL1, 'NAME2', VAL2, ...)
%			- Specifies additional name-value pairs described below:
%
% 'Training'
% 			Boolean indicating whether the network is being evaluated for
%			prediction or training. If TRAINING is true, state variables
%			will be updated.
%
% 'InputDataPermutation'
%			'auto' - Automatically attempt to determine the permutation
%			 between the dimensions of the input data and the dimensions of
%			the ONNX model input. For example, the permutation from HWCN
%			(MATLAB standard) to NCHW (ONNX standard) uses the vector
%			[4 3 1 2]. See the documentation for IMPORTONNXFUNCTION for
%			more information about automatic permutation.
%
%			'none' - Input(s) are passed in the ONNX model format. See 'Inputs'.
%
%			numeric vector - The permutation vector describing the
%			transformation between input data dimensions and the expected
%			ONNX input dimensions.%
%			cell array - If the network has multiple inputs, each cell
%			contains 'auto', 'none', or a numeric vector.
%
% 'OutputDataPermutation'
%			'auto' - Automatically attempt to determine the permutation
%			between the dimensions of the output and a conventional MATLAB
%			dimension ordering. For example, the permutation from NC (ONNX
%			standard) to CN (MATLAB standard) uses the vector [2 1]. See
%			the documentation for IMPORTONNXFUNCTION for more information
%			about automatic permutation.
%
%			'none' - Return output(s) as given by the ONNX model. See 'Outputs'.
%
%			numeric vector - The permutation vector describing the
%			transformation between the ONNX output dimensions and the
%			desired output dimensions.%
%			cell array - If the network has multiple outputs, each cell
%			contains 'auto', 'none' or a numeric vector.
%
% Inputs:
% -------
% INPUT
%			- Input(s) to the ONNX network.
%			  The input size(s) expected by the ONNX file are:
%				  INPUT:		[batch_size, 3]				Type: FLOAT
%			  By default, the function will try to permute the input(s)
%			  into this dimension ordering. If the default is incorrect,
%			  use the 'InputDataPermutation' argument to control the
%			  permutation.
%
%
% PARAMS	- Network parameters returned by 'importONNXFunction'.
%
%
% Outputs:
% --------
% OUTPUT
%			- Output(s) of the ONNX network.
%			  Without permutation, the size(s) of the outputs are:
%				  OUTPUT:		[batch_size, 1]				Type: FLOAT
%			  By default, the function will try to permute the output(s)
%			  from this dimension ordering into a conventional MATLAB
%			  ordering. If the default is incorrect, use the
%			  'OutputDataPermutation' argument to control the permutation.
%
% STATE		- (Optional) State variables. When TRAINING is true, these will
% 			  have been updated from the original values in PARAMS.State.
%
%
%  See also importONNXFunction

% Preprocess the input data and arguments:
[input, Training, outputDataPerms, anyDlarrayInputs] = preprocessInput(input, params, varargin{:});
% Put all variables into a single struct to implement dynamic scoping:
[Vars, NumDims] = packageVariables(params, {'input'}, {input}, [2]);
% Call the top-level graph function:
[output, NumDims.output, state] = torch_jit_exportGraph1000(input, NumDims.input, Vars, NumDims, Training, params.State);
% Postprocess the output data
[output] = postprocessOutput(output, outputDataPerms, anyDlarrayInputs, Training, varargin{:});
end

function [output, outputNumDims1037, state] = torch_jit_exportGraph1000(input, inputNumDims1036, Vars, NumDims, Training, state)
% Function implementing the graph 'torch_jit_exportGraph1000'
% Update Vars and NumDims from the graph's formal input parameters. Note that state variables are already in Vars.
Vars.input = input;
NumDims.input = inputNumDims1036;

% Execute the operators:
% Slice:
[Indices, NumDims.x18] = prepareSliceArgs(Vars.input, Vars.x15, Vars.x16, Vars.x14, Vars.x17, NumDims.input);
Vars.x18 = subsref(Vars.input, Indices);

% Abs:
Vars.x21 = abs(Vars.x458);
NumDims.x21 = NumDims.x458;

% Add:
Vars.x23 = Vars.x21 + Vars.x22;
NumDims.x23 = max(NumDims.x21, NumDims.x22);

% Div:
Vars.x25 = Vars.x24 ./ Vars.x23;
NumDims.x25 = max(NumDims.x24, NumDims.x23);

% Abs:
Vars.x26 = abs(Vars.layer_fuzzify_varmfs_distance_center_width);
NumDims.x26 = NumDims.layer_fuzzify_varmfs_distance_center_width;

% Abs:
Vars.x27 = abs(Vars.layer_fuzzify_varmfs_distance_side_width);
NumDims.x27 = NumDims.layer_fuzzify_varmfs_distance_side_width;

% Sub:
Vars.x29 = Vars.x18 - Vars.x28;
NumDims.x29 = max(NumDims.x18, NumDims.x28);

% Shape:
[Vars.x30, NumDims.x30] = onnxShape(Vars.x29, NumDims.x29);

% ConstantOfShape:
[Vars.x31, NumDims.x31] = onnxConstantOfShape(Vars.ConstantOfShapeValue1001, Vars.x30);

% Shape:
[Vars.x32, NumDims.x32] = onnxShape(Vars.x29, NumDims.x29);

% ConstantOfShape:
[Vars.x33, NumDims.x33] = onnxConstantOfShape(Vars.ConstantOfShapeValue1002, Vars.x32);

% Abs:
Vars.x34 = abs(Vars.x29);
NumDims.x34 = NumDims.x29;

% Div:
Vars.x37 = Vars.x26 ./ Vars.x459;
NumDims.x37 = max(NumDims.x26, NumDims.x459);

% Greater:
Vars.x38 = Vars.x34 > Vars.x37;
NumDims.x38 = max(NumDims.x34, NumDims.x37);

% Not:
Vars.x39 = not(Vars.x38);
NumDims.x39 = NumDims.x38;

% Add:
Vars.x40 = Vars.x37 + Vars.x25;
NumDims.x40 = max(NumDims.x37, NumDims.x25);

% Greater:
Vars.x41 = Vars.x34 > Vars.x40;
NumDims.x41 = max(NumDims.x34, NumDims.x40);

% Not:
Vars.x42 = not(Vars.x41);
NumDims.x42 = NumDims.x41;

% Not:
Vars.x43 = not(Vars.x39);
NumDims.x43 = NumDims.x39;

% Cast:
Vars.x44 = logical(Vars.x43);
NumDims.x44 = NumDims.x43;

% Cast:
Vars.x45 = logical(Vars.x42);
NumDims.x45 = NumDims.x42;

% And:
Vars.x46 = Vars.x44 & Vars.x45;
NumDims.x46 = max(NumDims.x44, NumDims.x45);

% Cast:
Vars.x47 = logical(Vars.x46);
NumDims.x47 = NumDims.x46;

% Neg:
Vars.x48 = -(Vars.x23);
NumDims.x48 = NumDims.x23;

% Sub:
Vars.x49 = Vars.x34 - Vars.x37;
NumDims.x49 = max(NumDims.x34, NumDims.x37);

% Mul:
Vars.x50 = Vars.x48 .* Vars.x49;
NumDims.x50 = max(NumDims.x48, NumDims.x49);

% Add:
Vars.x52 = Vars.x50 + Vars.x51;
NumDims.x52 = max(NumDims.x50, NumDims.x51);

% Where:
[Vars.x53, NumDims.x53] = onnxWhere(Vars.x47, Vars.x52, Vars.x33, NumDims.x47, NumDims.x52, NumDims.x33);

% Where:
[Vars.x54, NumDims.x54] = onnxWhere(Vars.x39, Vars.x31, Vars.x53, NumDims.x39, NumDims.x31, NumDims.x53);

% Div:
Vars.x57 = Vars.x27 ./ Vars.x460;
NumDims.x57 = max(NumDims.x27, NumDims.x460);

% Add:
Vars.x58 = Vars.x37 + Vars.x57;
NumDims.x58 = max(NumDims.x37, NumDims.x57);

% Add:
Vars.x59 = Vars.x58 + Vars.x25;
NumDims.x59 = max(NumDims.x58, NumDims.x25);

% Mul:
Vars.x60 = Vars.x23 .* Vars.x57;
NumDims.x60 = max(NumDims.x23, NumDims.x57);

% Add:
Vars.x62 = Vars.x60 + Vars.x61;
NumDims.x62 = max(NumDims.x60, NumDims.x61);

% Add:
Vars.x63 = Vars.x29 + Vars.x59;
NumDims.x63 = max(NumDims.x29, NumDims.x59);

% Abs:
Vars.x64 = abs(Vars.x63);
NumDims.x64 = NumDims.x63;

% Greater:
Vars.x65 = Vars.x64 > Vars.x57;
NumDims.x65 = max(NumDims.x64, NumDims.x57);

% Not:
Vars.x66 = not(Vars.x65);
NumDims.x66 = NumDims.x65;

% Add:
Vars.x67 = Vars.x57 + Vars.x25;
NumDims.x67 = max(NumDims.x57, NumDims.x25);

% Greater:
Vars.x68 = Vars.x64 > Vars.x67;
NumDims.x68 = max(NumDims.x64, NumDims.x67);

% Not:
Vars.x69 = not(Vars.x68);
NumDims.x69 = NumDims.x68;

% Not:
Vars.x70 = not(Vars.x66);
NumDims.x70 = NumDims.x66;

% Cast:
Vars.x71 = logical(Vars.x70);
NumDims.x71 = NumDims.x70;

% Cast:
Vars.x72 = logical(Vars.x69);
NumDims.x72 = NumDims.x69;

% And:
Vars.x73 = Vars.x71 & Vars.x72;
NumDims.x73 = max(NumDims.x71, NumDims.x72);

% Cast:
Vars.x74 = logical(Vars.x73);
NumDims.x74 = NumDims.x73;

% Neg:
Vars.x75 = -(Vars.x23);
NumDims.x75 = NumDims.x23;

% Mul:
Vars.x76 = Vars.x75 .* Vars.x64;
NumDims.x76 = max(NumDims.x75, NumDims.x64);

% Add:
Vars.x77 = Vars.x76 + Vars.x62;
NumDims.x77 = max(NumDims.x76, NumDims.x62);

% Where:
[Vars.x78, NumDims.x78] = onnxWhere(Vars.x74, Vars.x77, Vars.x33, NumDims.x74, NumDims.x77, NumDims.x33);

% Where:
[Vars.x79, NumDims.x79] = onnxWhere(Vars.x66, Vars.x31, Vars.x78, NumDims.x66, NumDims.x31, NumDims.x78);

% Sub:
Vars.x80 = Vars.x29 - Vars.x59;
NumDims.x80 = max(NumDims.x29, NumDims.x59);

% Abs:
Vars.x81 = abs(Vars.x80);
NumDims.x81 = NumDims.x80;

% Greater:
Vars.x82 = Vars.x81 > Vars.x57;
NumDims.x82 = max(NumDims.x81, NumDims.x57);

% Not:
Vars.x83 = not(Vars.x82);
NumDims.x83 = NumDims.x82;

% Add:
Vars.x84 = Vars.x57 + Vars.x25;
NumDims.x84 = max(NumDims.x57, NumDims.x25);

% Greater:
Vars.x85 = Vars.x81 > Vars.x84;
NumDims.x85 = max(NumDims.x81, NumDims.x84);

% Not:
Vars.x86 = not(Vars.x85);
NumDims.x86 = NumDims.x85;

% Not:
Vars.x87 = not(Vars.x83);
NumDims.x87 = NumDims.x83;

% Cast:
Vars.x88 = logical(Vars.x87);
NumDims.x88 = NumDims.x87;

% Cast:
Vars.x89 = logical(Vars.x86);
NumDims.x89 = NumDims.x86;

% And:
Vars.x90 = Vars.x88 & Vars.x89;
NumDims.x90 = max(NumDims.x88, NumDims.x89);

% Cast:
Vars.x91 = logical(Vars.x90);
NumDims.x91 = NumDims.x90;

% Neg:
Vars.x92 = -(Vars.x23);
NumDims.x92 = NumDims.x23;

% Mul:
Vars.x93 = Vars.x92 .* Vars.x81;
NumDims.x93 = max(NumDims.x92, NumDims.x81);

% Add:
Vars.x94 = Vars.x93 + Vars.x62;
NumDims.x94 = max(NumDims.x93, NumDims.x62);

% Where:
[Vars.x95, NumDims.x95] = onnxWhere(Vars.x91, Vars.x94, Vars.x33, NumDims.x91, NumDims.x94, NumDims.x33);

% Where:
[Vars.x96, NumDims.x96] = onnxWhere(Vars.x83, Vars.x31, Vars.x95, NumDims.x83, NumDims.x31, NumDims.x95);

% Add:
Vars.x97 = Vars.x37 + Vars.x27;
NumDims.x97 = max(NumDims.x37, NumDims.x27);

% Mul:
Vars.x99 = Vars.x25 .* Vars.x98;
NumDims.x99 = max(NumDims.x25, NumDims.x98);

% Add:
Vars.x100 = Vars.x97 + Vars.x99;
NumDims.x100 = max(NumDims.x97, NumDims.x99);

% Mul:
Vars.x101 = Vars.x23 .* Vars.x25;
NumDims.x101 = max(NumDims.x23, NumDims.x25);

% Neg:
Vars.x102 = -(Vars.x29);
NumDims.x102 = NumDims.x29;

% Sub:
Vars.x103 = Vars.x102 - Vars.x100;
NumDims.x103 = max(NumDims.x102, NumDims.x100);

% Greater:
Vars.x105 = Vars.x103 > Vars.x104;
NumDims.x105 = max(NumDims.x103, NumDims.x104);

% Neg:
Vars.x106 = -(Vars.x25);
NumDims.x106 = NumDims.x25;

% Less:
Vars.x107 = Vars.x103 < Vars.x106;
NumDims.x107 = max(NumDims.x103, NumDims.x106);

% Not:
Vars.x108 = not(Vars.x107);
NumDims.x108 = NumDims.x107;

% Not:
Vars.x109 = not(Vars.x105);
NumDims.x109 = NumDims.x105;

% Cast:
Vars.x110 = logical(Vars.x109);
NumDims.x110 = NumDims.x109;

% Cast:
Vars.x111 = logical(Vars.x108);
NumDims.x111 = NumDims.x108;

% And:
Vars.x112 = Vars.x110 & Vars.x111;
NumDims.x112 = max(NumDims.x110, NumDims.x111);

% Cast:
Vars.x113 = logical(Vars.x112);
NumDims.x113 = NumDims.x112;

% Mul:
Vars.x114 = Vars.x23 .* Vars.x103;
NumDims.x114 = max(NumDims.x23, NumDims.x103);

% Add:
Vars.x115 = Vars.x114 + Vars.x101;
NumDims.x115 = max(NumDims.x114, NumDims.x101);

% Where:
[Vars.x116, NumDims.x116] = onnxWhere(Vars.x113, Vars.x115, Vars.x33, NumDims.x113, NumDims.x115, NumDims.x33);

% Where:
[Vars.x117, NumDims.x117] = onnxWhere(Vars.x105, Vars.x31, Vars.x116, NumDims.x105, NumDims.x31, NumDims.x116);

% Sub:
Vars.x118 = Vars.x29 - Vars.x100;
NumDims.x118 = max(NumDims.x29, NumDims.x100);

% Greater:
Vars.x120 = Vars.x118 > Vars.x119;
NumDims.x120 = max(NumDims.x118, NumDims.x119);

% Neg:
Vars.x121 = -(Vars.x25);
NumDims.x121 = NumDims.x25;

% Less:
Vars.x122 = Vars.x118 < Vars.x121;
NumDims.x122 = max(NumDims.x118, NumDims.x121);

% Not:
Vars.x123 = not(Vars.x122);
NumDims.x123 = NumDims.x122;

% Not:
Vars.x124 = not(Vars.x120);
NumDims.x124 = NumDims.x120;

% Cast:
Vars.x125 = logical(Vars.x124);
NumDims.x125 = NumDims.x124;

% Cast:
Vars.x126 = logical(Vars.x123);
NumDims.x126 = NumDims.x123;

% And:
Vars.x127 = Vars.x125 & Vars.x126;
NumDims.x127 = max(NumDims.x125, NumDims.x126);

% Cast:
Vars.x128 = logical(Vars.x127);
NumDims.x128 = NumDims.x127;

% Mul:
Vars.x129 = Vars.x23 .* Vars.x118;
NumDims.x129 = max(NumDims.x23, NumDims.x118);

% Add:
Vars.x130 = Vars.x129 + Vars.x101;
NumDims.x130 = max(NumDims.x129, NumDims.x101);

% Where:
[Vars.x131, NumDims.x131] = onnxWhere(Vars.x128, Vars.x130, Vars.x33, NumDims.x128, NumDims.x130, NumDims.x33);

% Where:
[Vars.x132, NumDims.x132] = onnxWhere(Vars.x120, Vars.x31, Vars.x131, NumDims.x120, NumDims.x31, NumDims.x131);

% Concat:
[dim, NumDims.x133] = prepareConcatArgs(1, [NumDims.x117, NumDims.x79, NumDims.x54, NumDims.x96, NumDims.x132]);
Vars.x133 = cat(dim, Vars.x117, Vars.x79, Vars.x54, Vars.x96, Vars.x132);

% Slice:
[Indices, NumDims.x138] = prepareSliceArgs(Vars.input, Vars.x135, Vars.x136, Vars.x134, Vars.x137, NumDims.input);
Vars.x138 = subsref(Vars.input, Indices);

% Abs:
Vars.x141 = abs(Vars.x461);
NumDims.x141 = NumDims.x461;

% Add:
Vars.x143 = Vars.x141 + Vars.x142;
NumDims.x143 = max(NumDims.x141, NumDims.x142);

% Div:
Vars.x145 = Vars.x144 ./ Vars.x143;
NumDims.x145 = max(NumDims.x144, NumDims.x143);

% Abs:
Vars.x146 = abs(Vars.layer_fuzzify_varmfs_theta_far_center_width);
NumDims.x146 = NumDims.layer_fuzzify_varmfs_theta_far_center_width;

% Abs:
Vars.x147 = abs(Vars.layer_fuzzify_varmfs_theta_far_side_width);
NumDims.x147 = NumDims.layer_fuzzify_varmfs_theta_far_side_width;

% Sub:
Vars.x149 = Vars.x138 - Vars.x148;
NumDims.x149 = max(NumDims.x138, NumDims.x148);

% Shape:
[Vars.x150, NumDims.x150] = onnxShape(Vars.x149, NumDims.x149);

% ConstantOfShape:
[Vars.x151, NumDims.x151] = onnxConstantOfShape(Vars.ConstantOfShapeValue1003, Vars.x150);

% Shape:
[Vars.x152, NumDims.x152] = onnxShape(Vars.x149, NumDims.x149);

% ConstantOfShape:
[Vars.x153, NumDims.x153] = onnxConstantOfShape(Vars.ConstantOfShapeValue1004, Vars.x152);

% Abs:
Vars.x154 = abs(Vars.x149);
NumDims.x154 = NumDims.x149;

% Div:
Vars.x157 = Vars.x146 ./ Vars.x462;
NumDims.x157 = max(NumDims.x146, NumDims.x462);

% Greater:
Vars.x158 = Vars.x154 > Vars.x157;
NumDims.x158 = max(NumDims.x154, NumDims.x157);

% Not:
Vars.x159 = not(Vars.x158);
NumDims.x159 = NumDims.x158;

% Add:
Vars.x160 = Vars.x157 + Vars.x145;
NumDims.x160 = max(NumDims.x157, NumDims.x145);

% Greater:
Vars.x161 = Vars.x154 > Vars.x160;
NumDims.x161 = max(NumDims.x154, NumDims.x160);

% Not:
Vars.x162 = not(Vars.x161);
NumDims.x162 = NumDims.x161;

% Not:
Vars.x163 = not(Vars.x159);
NumDims.x163 = NumDims.x159;

% Cast:
Vars.x164 = logical(Vars.x163);
NumDims.x164 = NumDims.x163;

% Cast:
Vars.x165 = logical(Vars.x162);
NumDims.x165 = NumDims.x162;

% And:
Vars.x166 = Vars.x164 & Vars.x165;
NumDims.x166 = max(NumDims.x164, NumDims.x165);

% Cast:
Vars.x167 = logical(Vars.x166);
NumDims.x167 = NumDims.x166;

% Neg:
Vars.x168 = -(Vars.x143);
NumDims.x168 = NumDims.x143;

% Sub:
Vars.x169 = Vars.x154 - Vars.x157;
NumDims.x169 = max(NumDims.x154, NumDims.x157);

% Mul:
Vars.x170 = Vars.x168 .* Vars.x169;
NumDims.x170 = max(NumDims.x168, NumDims.x169);

% Add:
Vars.x172 = Vars.x170 + Vars.x171;
NumDims.x172 = max(NumDims.x170, NumDims.x171);

% Where:
[Vars.x173, NumDims.x173] = onnxWhere(Vars.x167, Vars.x172, Vars.x153, NumDims.x167, NumDims.x172, NumDims.x153);

% Where:
[Vars.x174, NumDims.x174] = onnxWhere(Vars.x159, Vars.x151, Vars.x173, NumDims.x159, NumDims.x151, NumDims.x173);

% Div:
Vars.x177 = Vars.x147 ./ Vars.x463;
NumDims.x177 = max(NumDims.x147, NumDims.x463);

% Add:
Vars.x178 = Vars.x157 + Vars.x177;
NumDims.x178 = max(NumDims.x157, NumDims.x177);

% Add:
Vars.x179 = Vars.x178 + Vars.x145;
NumDims.x179 = max(NumDims.x178, NumDims.x145);

% Mul:
Vars.x180 = Vars.x143 .* Vars.x177;
NumDims.x180 = max(NumDims.x143, NumDims.x177);

% Add:
Vars.x182 = Vars.x180 + Vars.x181;
NumDims.x182 = max(NumDims.x180, NumDims.x181);

% Add:
Vars.x183 = Vars.x149 + Vars.x179;
NumDims.x183 = max(NumDims.x149, NumDims.x179);

% Abs:
Vars.x184 = abs(Vars.x183);
NumDims.x184 = NumDims.x183;

% Greater:
Vars.x185 = Vars.x184 > Vars.x177;
NumDims.x185 = max(NumDims.x184, NumDims.x177);

% Not:
Vars.x186 = not(Vars.x185);
NumDims.x186 = NumDims.x185;

% Add:
Vars.x187 = Vars.x177 + Vars.x145;
NumDims.x187 = max(NumDims.x177, NumDims.x145);

% Greater:
Vars.x188 = Vars.x184 > Vars.x187;
NumDims.x188 = max(NumDims.x184, NumDims.x187);

% Not:
Vars.x189 = not(Vars.x188);
NumDims.x189 = NumDims.x188;

% Not:
Vars.x190 = not(Vars.x186);
NumDims.x190 = NumDims.x186;

% Cast:
Vars.x191 = logical(Vars.x190);
NumDims.x191 = NumDims.x190;

% Cast:
Vars.x192 = logical(Vars.x189);
NumDims.x192 = NumDims.x189;

% And:
Vars.x193 = Vars.x191 & Vars.x192;
NumDims.x193 = max(NumDims.x191, NumDims.x192);

% Cast:
Vars.x194 = logical(Vars.x193);
NumDims.x194 = NumDims.x193;

% Neg:
Vars.x195 = -(Vars.x143);
NumDims.x195 = NumDims.x143;

% Mul:
Vars.x196 = Vars.x195 .* Vars.x184;
NumDims.x196 = max(NumDims.x195, NumDims.x184);

% Add:
Vars.x197 = Vars.x196 + Vars.x182;
NumDims.x197 = max(NumDims.x196, NumDims.x182);

% Where:
[Vars.x198, NumDims.x198] = onnxWhere(Vars.x194, Vars.x197, Vars.x153, NumDims.x194, NumDims.x197, NumDims.x153);

% Where:
[Vars.x199, NumDims.x199] = onnxWhere(Vars.x186, Vars.x151, Vars.x198, NumDims.x186, NumDims.x151, NumDims.x198);

% Sub:
Vars.x200 = Vars.x149 - Vars.x179;
NumDims.x200 = max(NumDims.x149, NumDims.x179);

% Abs:
Vars.x201 = abs(Vars.x200);
NumDims.x201 = NumDims.x200;

% Greater:
Vars.x202 = Vars.x201 > Vars.x177;
NumDims.x202 = max(NumDims.x201, NumDims.x177);

% Not:
Vars.x203 = not(Vars.x202);
NumDims.x203 = NumDims.x202;

% Add:
Vars.x204 = Vars.x177 + Vars.x145;
NumDims.x204 = max(NumDims.x177, NumDims.x145);

% Greater:
Vars.x205 = Vars.x201 > Vars.x204;
NumDims.x205 = max(NumDims.x201, NumDims.x204);

% Not:
Vars.x206 = not(Vars.x205);
NumDims.x206 = NumDims.x205;

% Not:
Vars.x207 = not(Vars.x203);
NumDims.x207 = NumDims.x203;

% Cast:
Vars.x208 = logical(Vars.x207);
NumDims.x208 = NumDims.x207;

% Cast:
Vars.x209 = logical(Vars.x206);
NumDims.x209 = NumDims.x206;

% And:
Vars.x210 = Vars.x208 & Vars.x209;
NumDims.x210 = max(NumDims.x208, NumDims.x209);

% Cast:
Vars.x211 = logical(Vars.x210);
NumDims.x211 = NumDims.x210;

% Neg:
Vars.x212 = -(Vars.x143);
NumDims.x212 = NumDims.x143;

% Mul:
Vars.x213 = Vars.x212 .* Vars.x201;
NumDims.x213 = max(NumDims.x212, NumDims.x201);

% Add:
Vars.x214 = Vars.x213 + Vars.x182;
NumDims.x214 = max(NumDims.x213, NumDims.x182);

% Where:
[Vars.x215, NumDims.x215] = onnxWhere(Vars.x211, Vars.x214, Vars.x153, NumDims.x211, NumDims.x214, NumDims.x153);

% Where:
[Vars.x216, NumDims.x216] = onnxWhere(Vars.x203, Vars.x151, Vars.x215, NumDims.x203, NumDims.x151, NumDims.x215);

% Add:
Vars.x217 = Vars.x157 + Vars.x147;
NumDims.x217 = max(NumDims.x157, NumDims.x147);

% Mul:
Vars.x219 = Vars.x145 .* Vars.x218;
NumDims.x219 = max(NumDims.x145, NumDims.x218);

% Add:
Vars.x220 = Vars.x217 + Vars.x219;
NumDims.x220 = max(NumDims.x217, NumDims.x219);

% Mul:
Vars.x221 = Vars.x143 .* Vars.x145;
NumDims.x221 = max(NumDims.x143, NumDims.x145);

% Neg:
Vars.x222 = -(Vars.x149);
NumDims.x222 = NumDims.x149;

% Sub:
Vars.x223 = Vars.x222 - Vars.x220;
NumDims.x223 = max(NumDims.x222, NumDims.x220);

% Greater:
Vars.x225 = Vars.x223 > Vars.x224;
NumDims.x225 = max(NumDims.x223, NumDims.x224);

% Neg:
Vars.x226 = -(Vars.x145);
NumDims.x226 = NumDims.x145;

% Less:
Vars.x227 = Vars.x223 < Vars.x226;
NumDims.x227 = max(NumDims.x223, NumDims.x226);

% Not:
Vars.x228 = not(Vars.x227);
NumDims.x228 = NumDims.x227;

% Not:
Vars.x229 = not(Vars.x225);
NumDims.x229 = NumDims.x225;

% Cast:
Vars.x230 = logical(Vars.x229);
NumDims.x230 = NumDims.x229;

% Cast:
Vars.x231 = logical(Vars.x228);
NumDims.x231 = NumDims.x228;

% And:
Vars.x232 = Vars.x230 & Vars.x231;
NumDims.x232 = max(NumDims.x230, NumDims.x231);

% Cast:
Vars.x233 = logical(Vars.x232);
NumDims.x233 = NumDims.x232;

% Mul:
Vars.x234 = Vars.x143 .* Vars.x223;
NumDims.x234 = max(NumDims.x143, NumDims.x223);

% Add:
Vars.x235 = Vars.x234 + Vars.x221;
NumDims.x235 = max(NumDims.x234, NumDims.x221);

% Where:
[Vars.x236, NumDims.x236] = onnxWhere(Vars.x233, Vars.x235, Vars.x153, NumDims.x233, NumDims.x235, NumDims.x153);

% Where:
[Vars.x237, NumDims.x237] = onnxWhere(Vars.x225, Vars.x151, Vars.x236, NumDims.x225, NumDims.x151, NumDims.x236);

% Sub:
Vars.x238 = Vars.x149 - Vars.x220;
NumDims.x238 = max(NumDims.x149, NumDims.x220);

% Greater:
Vars.x240 = Vars.x238 > Vars.x239;
NumDims.x240 = max(NumDims.x238, NumDims.x239);

% Neg:
Vars.x241 = -(Vars.x145);
NumDims.x241 = NumDims.x145;

% Less:
Vars.x242 = Vars.x238 < Vars.x241;
NumDims.x242 = max(NumDims.x238, NumDims.x241);

% Not:
Vars.x243 = not(Vars.x242);
NumDims.x243 = NumDims.x242;

% Not:
Vars.x244 = not(Vars.x240);
NumDims.x244 = NumDims.x240;

% Cast:
Vars.x245 = logical(Vars.x244);
NumDims.x245 = NumDims.x244;

% Cast:
Vars.x246 = logical(Vars.x243);
NumDims.x246 = NumDims.x243;

% And:
Vars.x247 = Vars.x245 & Vars.x246;
NumDims.x247 = max(NumDims.x245, NumDims.x246);

% Cast:
Vars.x248 = logical(Vars.x247);
NumDims.x248 = NumDims.x247;

% Mul:
Vars.x249 = Vars.x143 .* Vars.x238;
NumDims.x249 = max(NumDims.x143, NumDims.x238);

% Add:
Vars.x250 = Vars.x249 + Vars.x221;
NumDims.x250 = max(NumDims.x249, NumDims.x221);

% Where:
[Vars.x251, NumDims.x251] = onnxWhere(Vars.x248, Vars.x250, Vars.x153, NumDims.x248, NumDims.x250, NumDims.x153);

% Where:
[Vars.x252, NumDims.x252] = onnxWhere(Vars.x240, Vars.x151, Vars.x251, NumDims.x240, NumDims.x151, NumDims.x251);

% Concat:
[dim, NumDims.x253] = prepareConcatArgs(1, [NumDims.x237, NumDims.x199, NumDims.x174, NumDims.x216, NumDims.x252]);
Vars.x253 = cat(dim, Vars.x237, Vars.x199, Vars.x174, Vars.x216, Vars.x252);

% Slice:
[Indices, NumDims.x258] = prepareSliceArgs(Vars.input, Vars.x255, Vars.x256, Vars.x254, Vars.x257, NumDims.input);
Vars.x258 = subsref(Vars.input, Indices);

% Abs:
Vars.x261 = abs(Vars.x464);
NumDims.x261 = NumDims.x464;

% Add:
Vars.x263 = Vars.x261 + Vars.x262;
NumDims.x263 = max(NumDims.x261, NumDims.x262);

% Div:
Vars.x265 = Vars.x264 ./ Vars.x263;
NumDims.x265 = max(NumDims.x264, NumDims.x263);

% Abs:
Vars.x266 = abs(Vars.layer_fuzzify_varmfs_theta_near_center_width);
NumDims.x266 = NumDims.layer_fuzzify_varmfs_theta_near_center_width;

% Abs:
Vars.x267 = abs(Vars.layer_fuzzify_varmfs_theta_near_side_width);
NumDims.x267 = NumDims.layer_fuzzify_varmfs_theta_near_side_width;

% Sub:
Vars.x269 = Vars.x258 - Vars.x268;
NumDims.x269 = max(NumDims.x258, NumDims.x268);

% Shape:
[Vars.x270, NumDims.x270] = onnxShape(Vars.x269, NumDims.x269);

% ConstantOfShape:
[Vars.x271, NumDims.x271] = onnxConstantOfShape(Vars.ConstantOfShapeValue1005, Vars.x270);

% Shape:
[Vars.x272, NumDims.x272] = onnxShape(Vars.x269, NumDims.x269);

% ConstantOfShape:
[Vars.x273, NumDims.x273] = onnxConstantOfShape(Vars.ConstantOfShapeValue1006, Vars.x272);

% Abs:
Vars.x274 = abs(Vars.x269);
NumDims.x274 = NumDims.x269;

% Div:
Vars.x277 = Vars.x266 ./ Vars.x465;
NumDims.x277 = max(NumDims.x266, NumDims.x465);

% Greater:
Vars.x278 = Vars.x274 > Vars.x277;
NumDims.x278 = max(NumDims.x274, NumDims.x277);

% Not:
Vars.x279 = not(Vars.x278);
NumDims.x279 = NumDims.x278;

% Add:
Vars.x280 = Vars.x277 + Vars.x265;
NumDims.x280 = max(NumDims.x277, NumDims.x265);

% Greater:
Vars.x281 = Vars.x274 > Vars.x280;
NumDims.x281 = max(NumDims.x274, NumDims.x280);

% Not:
Vars.x282 = not(Vars.x281);
NumDims.x282 = NumDims.x281;

% Not:
Vars.x283 = not(Vars.x279);
NumDims.x283 = NumDims.x279;

% Cast:
Vars.x284 = logical(Vars.x283);
NumDims.x284 = NumDims.x283;

% Cast:
Vars.x285 = logical(Vars.x282);
NumDims.x285 = NumDims.x282;

% And:
Vars.x286 = Vars.x284 & Vars.x285;
NumDims.x286 = max(NumDims.x284, NumDims.x285);

% Cast:
Vars.x287 = logical(Vars.x286);
NumDims.x287 = NumDims.x286;

% Neg:
Vars.x288 = -(Vars.x263);
NumDims.x288 = NumDims.x263;

% Sub:
Vars.x289 = Vars.x274 - Vars.x277;
NumDims.x289 = max(NumDims.x274, NumDims.x277);

% Mul:
Vars.x290 = Vars.x288 .* Vars.x289;
NumDims.x290 = max(NumDims.x288, NumDims.x289);

% Add:
Vars.x292 = Vars.x290 + Vars.x291;
NumDims.x292 = max(NumDims.x290, NumDims.x291);

% Where:
[Vars.x293, NumDims.x293] = onnxWhere(Vars.x287, Vars.x292, Vars.x273, NumDims.x287, NumDims.x292, NumDims.x273);

% Where:
[Vars.x294, NumDims.x294] = onnxWhere(Vars.x279, Vars.x271, Vars.x293, NumDims.x279, NumDims.x271, NumDims.x293);

% Div:
Vars.x297 = Vars.x267 ./ Vars.x466;
NumDims.x297 = max(NumDims.x267, NumDims.x466);

% Add:
Vars.x298 = Vars.x277 + Vars.x297;
NumDims.x298 = max(NumDims.x277, NumDims.x297);

% Add:
Vars.x299 = Vars.x298 + Vars.x265;
NumDims.x299 = max(NumDims.x298, NumDims.x265);

% Mul:
Vars.x300 = Vars.x263 .* Vars.x297;
NumDims.x300 = max(NumDims.x263, NumDims.x297);

% Add:
Vars.x302 = Vars.x300 + Vars.x301;
NumDims.x302 = max(NumDims.x300, NumDims.x301);

% Add:
Vars.x303 = Vars.x269 + Vars.x299;
NumDims.x303 = max(NumDims.x269, NumDims.x299);

% Abs:
Vars.x304 = abs(Vars.x303);
NumDims.x304 = NumDims.x303;

% Greater:
Vars.x305 = Vars.x304 > Vars.x297;
NumDims.x305 = max(NumDims.x304, NumDims.x297);

% Not:
Vars.x306 = not(Vars.x305);
NumDims.x306 = NumDims.x305;

% Add:
Vars.x307 = Vars.x297 + Vars.x265;
NumDims.x307 = max(NumDims.x297, NumDims.x265);

% Greater:
Vars.x308 = Vars.x304 > Vars.x307;
NumDims.x308 = max(NumDims.x304, NumDims.x307);

% Not:
Vars.x309 = not(Vars.x308);
NumDims.x309 = NumDims.x308;

% Not:
Vars.x310 = not(Vars.x306);
NumDims.x310 = NumDims.x306;

% Cast:
Vars.x311 = logical(Vars.x310);
NumDims.x311 = NumDims.x310;

% Cast:
Vars.x312 = logical(Vars.x309);
NumDims.x312 = NumDims.x309;

% And:
Vars.x313 = Vars.x311 & Vars.x312;
NumDims.x313 = max(NumDims.x311, NumDims.x312);

% Cast:
Vars.x314 = logical(Vars.x313);
NumDims.x314 = NumDims.x313;

% Neg:
Vars.x315 = -(Vars.x263);
NumDims.x315 = NumDims.x263;

% Mul:
Vars.x316 = Vars.x315 .* Vars.x304;
NumDims.x316 = max(NumDims.x315, NumDims.x304);

% Add:
Vars.x317 = Vars.x316 + Vars.x302;
NumDims.x317 = max(NumDims.x316, NumDims.x302);

% Where:
[Vars.x318, NumDims.x318] = onnxWhere(Vars.x314, Vars.x317, Vars.x273, NumDims.x314, NumDims.x317, NumDims.x273);

% Where:
[Vars.x319, NumDims.x319] = onnxWhere(Vars.x306, Vars.x271, Vars.x318, NumDims.x306, NumDims.x271, NumDims.x318);

% Sub:
Vars.x320 = Vars.x269 - Vars.x299;
NumDims.x320 = max(NumDims.x269, NumDims.x299);

% Abs:
Vars.x321 = abs(Vars.x320);
NumDims.x321 = NumDims.x320;

% Greater:
Vars.x322 = Vars.x321 > Vars.x297;
NumDims.x322 = max(NumDims.x321, NumDims.x297);

% Not:
Vars.x323 = not(Vars.x322);
NumDims.x323 = NumDims.x322;

% Add:
Vars.x324 = Vars.x297 + Vars.x265;
NumDims.x324 = max(NumDims.x297, NumDims.x265);

% Greater:
Vars.x325 = Vars.x321 > Vars.x324;
NumDims.x325 = max(NumDims.x321, NumDims.x324);

% Not:
Vars.x326 = not(Vars.x325);
NumDims.x326 = NumDims.x325;

% Not:
Vars.x327 = not(Vars.x323);
NumDims.x327 = NumDims.x323;

% Cast:
Vars.x328 = logical(Vars.x327);
NumDims.x328 = NumDims.x327;

% Cast:
Vars.x329 = logical(Vars.x326);
NumDims.x329 = NumDims.x326;

% And:
Vars.x330 = Vars.x328 & Vars.x329;
NumDims.x330 = max(NumDims.x328, NumDims.x329);

% Cast:
Vars.x331 = logical(Vars.x330);
NumDims.x331 = NumDims.x330;

% Neg:
Vars.x332 = -(Vars.x263);
NumDims.x332 = NumDims.x263;

% Mul:
Vars.x333 = Vars.x332 .* Vars.x321;
NumDims.x333 = max(NumDims.x332, NumDims.x321);

% Add:
Vars.x334 = Vars.x333 + Vars.x302;
NumDims.x334 = max(NumDims.x333, NumDims.x302);

% Where:
[Vars.x335, NumDims.x335] = onnxWhere(Vars.x331, Vars.x334, Vars.x273, NumDims.x331, NumDims.x334, NumDims.x273);

% Where:
[Vars.x336, NumDims.x336] = onnxWhere(Vars.x323, Vars.x271, Vars.x335, NumDims.x323, NumDims.x271, NumDims.x335);

% Add:
Vars.x337 = Vars.x277 + Vars.x267;
NumDims.x337 = max(NumDims.x277, NumDims.x267);

% Mul:
Vars.x339 = Vars.x265 .* Vars.x338;
NumDims.x339 = max(NumDims.x265, NumDims.x338);

% Add:
Vars.x340 = Vars.x337 + Vars.x339;
NumDims.x340 = max(NumDims.x337, NumDims.x339);

% Mul:
Vars.x341 = Vars.x263 .* Vars.x265;
NumDims.x341 = max(NumDims.x263, NumDims.x265);

% Neg:
Vars.x342 = -(Vars.x269);
NumDims.x342 = NumDims.x269;

% Sub:
Vars.x343 = Vars.x342 - Vars.x340;
NumDims.x343 = max(NumDims.x342, NumDims.x340);

% Greater:
Vars.x345 = Vars.x343 > Vars.x344;
NumDims.x345 = max(NumDims.x343, NumDims.x344);

% Neg:
Vars.x346 = -(Vars.x265);
NumDims.x346 = NumDims.x265;

% Less:
Vars.x347 = Vars.x343 < Vars.x346;
NumDims.x347 = max(NumDims.x343, NumDims.x346);

% Not:
Vars.x348 = not(Vars.x347);
NumDims.x348 = NumDims.x347;

% Not:
Vars.x349 = not(Vars.x345);
NumDims.x349 = NumDims.x345;

% Cast:
Vars.x350 = logical(Vars.x349);
NumDims.x350 = NumDims.x349;

% Cast:
Vars.x351 = logical(Vars.x348);
NumDims.x351 = NumDims.x348;

% And:
Vars.x352 = Vars.x350 & Vars.x351;
NumDims.x352 = max(NumDims.x350, NumDims.x351);

% Cast:
Vars.x353 = logical(Vars.x352);
NumDims.x353 = NumDims.x352;

% Mul:
Vars.x354 = Vars.x263 .* Vars.x343;
NumDims.x354 = max(NumDims.x263, NumDims.x343);

% Add:
Vars.x355 = Vars.x354 + Vars.x341;
NumDims.x355 = max(NumDims.x354, NumDims.x341);

% Where:
[Vars.x356, NumDims.x356] = onnxWhere(Vars.x353, Vars.x355, Vars.x273, NumDims.x353, NumDims.x355, NumDims.x273);

% Where:
[Vars.x357, NumDims.x357] = onnxWhere(Vars.x345, Vars.x271, Vars.x356, NumDims.x345, NumDims.x271, NumDims.x356);

% Sub:
Vars.x358 = Vars.x269 - Vars.x340;
NumDims.x358 = max(NumDims.x269, NumDims.x340);

% Greater:
Vars.x360 = Vars.x358 > Vars.x359;
NumDims.x360 = max(NumDims.x358, NumDims.x359);

% Neg:
Vars.x361 = -(Vars.x265);
NumDims.x361 = NumDims.x265;

% Less:
Vars.x362 = Vars.x358 < Vars.x361;
NumDims.x362 = max(NumDims.x358, NumDims.x361);

% Not:
Vars.x363 = not(Vars.x362);
NumDims.x363 = NumDims.x362;

% Not:
Vars.x364 = not(Vars.x360);
NumDims.x364 = NumDims.x360;

% Cast:
Vars.x365 = logical(Vars.x364);
NumDims.x365 = NumDims.x364;

% Cast:
Vars.x366 = logical(Vars.x363);
NumDims.x366 = NumDims.x363;

% And:
Vars.x367 = Vars.x365 & Vars.x366;
NumDims.x367 = max(NumDims.x365, NumDims.x366);

% Cast:
Vars.x368 = logical(Vars.x367);
NumDims.x368 = NumDims.x367;

% Mul:
Vars.x369 = Vars.x263 .* Vars.x358;
NumDims.x369 = max(NumDims.x263, NumDims.x358);

% Add:
Vars.x370 = Vars.x369 + Vars.x341;
NumDims.x370 = max(NumDims.x369, NumDims.x341);

% Where:
[Vars.x371, NumDims.x371] = onnxWhere(Vars.x368, Vars.x370, Vars.x273, NumDims.x368, NumDims.x370, NumDims.x273);

% Where:
[Vars.x372, NumDims.x372] = onnxWhere(Vars.x360, Vars.x271, Vars.x371, NumDims.x360, NumDims.x271, NumDims.x371);

% Concat:
[dim, NumDims.x373] = prepareConcatArgs(1, [NumDims.x357, NumDims.x319, NumDims.x294, NumDims.x336, NumDims.x372]);
Vars.x373 = cat(dim, Vars.x357, Vars.x319, Vars.x294, Vars.x336, Vars.x372);

% Unsqueeze:
[shape, NumDims.x374] = prepareUnsqueezeArgs(Vars.x133, Vars.UnsqueezeAxes1007, NumDims.x133);
Vars.x374 = reshape(Vars.x133, shape);

% Unsqueeze:
[shape, NumDims.x375] = prepareUnsqueezeArgs(Vars.x253, Vars.UnsqueezeAxes1008, NumDims.x253);
Vars.x375 = reshape(Vars.x253, shape);

% Unsqueeze:
[shape, NumDims.x376] = prepareUnsqueezeArgs(Vars.x373, Vars.UnsqueezeAxes1009, NumDims.x373);
Vars.x376 = reshape(Vars.x373, shape);

% Concat:
[dim, NumDims.x377] = prepareConcatArgs(1, [NumDims.x374, NumDims.x375, NumDims.x376]);
Vars.x377 = cat(dim, Vars.x374, Vars.x375, Vars.x376);

% Shape:
[Vars.x378, NumDims.x378] = onnxShape(Vars.x377, NumDims.x377);

% Gather:
[Vars.x380, NumDims.x380] = onnxGather(Vars.x378, Vars.x379, 0, NumDims.x378, NumDims.x379);

% Gather:
[Vars.x382, NumDims.x382] = onnxGather(Vars.x378, Vars.x381, 0, NumDims.x378, NumDims.x381);

% Transpose:
[perm, NumDims.x383] = prepareTransposeArgs(Vars.TransposePerm1010, NumDims.x377);
if ~isempty(perm)
    Vars.x383 = permute(Vars.x377, perm);
end

% Flatten:
[dim1, dim2, NumDims.x384] = prepareFlattenArgs(Vars.x383, 2, NumDims.x383);
Vars.x384 = reshape(Vars.x383, dim1, dim2);

% Mul:
Vars.x386 = Vars.x385 .* Vars.x382;
NumDims.x386 = max(NumDims.x385, NumDims.x382);

% Add:
Vars.x388 = Vars.x387 + Vars.x386;
NumDims.x388 = max(NumDims.x387, NumDims.x386);

% Gather:
[Vars.x389, NumDims.x389] = onnxGather(Vars.x384, Vars.x388, 0, NumDims.x384, NumDims.x388);

% Shape:
[Vars.x390, NumDims.x390] = onnxShape(Vars.x388, NumDims.x388);

% Concat:
[dim, NumDims.x392] = prepareConcatArgs(0, [NumDims.x391, NumDims.x380]);
Vars.x392 = cat(dim, Vars.x391, Vars.x380);

% Reshape:
[shape, NumDims.x393] = prepareReshapeArgs(Vars.x389, Vars.x392, NumDims.x389);
Vars.x393 = reshape(Vars.x389, shape{:});

% Transpose:
[perm, NumDims.x394] = prepareTransposeArgs(Vars.TransposePerm1011, NumDims.x393);
if ~isempty(perm)
    Vars.x394 = permute(Vars.x393, perm);
end

% Concat:
[dim, NumDims.x395] = prepareConcatArgs(0, [NumDims.x380, NumDims.x390]);
Vars.x395 = cat(dim, Vars.x380, Vars.x390);

% Reshape:
[shape, NumDims.x396] = prepareReshapeArgs(Vars.x394, Vars.x395, NumDims.x394);
Vars.x396 = reshape(Vars.x394, shape{:});

% ReduceMin:
dims = prepareReduceArgs(Vars.ReduceMinAxes1012, NumDims.x396);
Vars.x397 = min(Vars.x396, [], dims);
[Vars.x397, NumDims.x397] = onnxSqueeze(Vars.x397, Vars.ReduceMinAxes1012, NumDims.x396);

% PLACEHOLDER FUNCTION FOR UNSUPPORTED OPERATOR (ReduceL1):
[Vars.x398, NumDims.x398] = max(sum(abs(Vars.x397)));

% Clip:
Vars.x399 = min(Vars.Clipmax1014, max(Vars.Clipmin1013, Vars.x398));
NumDims.x399 = NumDims.x398;

% Shape:
[Vars.x400, NumDims.x400] = onnxShape(Vars.x397, NumDims.x397);

% Expand:
[shape, NumDims.x401] = prepareExpandArgs(Vars.x400);
Vars.x401 = Vars.x399 + zeros(shape);

% Div:
Vars.x402 = Vars.x397 ./ Vars.x401;
NumDims.x402 = max(NumDims.x397, NumDims.x401);

% Abs:
Vars.x403 = abs(Vars.layer_consequent_mamdani_defs_soft);
NumDims.x403 = NumDims.layer_consequent_mamdani_defs_soft;

% Abs:
Vars.x404 = abs(Vars.layer_consequent_mamdani_defs_normal);
NumDims.x404 = NumDims.layer_consequent_mamdani_defs_normal;

% Abs:
Vars.x405 = abs(Vars.layer_consequent_mamdani_defs_hard);
NumDims.x405 = NumDims.layer_consequent_mamdani_defs_hard;

% Add:
Vars.x406 = Vars.x403 + Vars.x404;
NumDims.x406 = max(NumDims.x403, NumDims.x404);

% Add:
Vars.x407 = Vars.x406 + Vars.x405;
NumDims.x407 = max(NumDims.x406, NumDims.x405);

% Mul:
Vars.x409 = Vars.x407 .* Vars.x408;
NumDims.x409 = max(NumDims.x407, NumDims.x408);

% Add:
Vars.x410 = Vars.layer_consequent_mamdani_defs_center + Vars.x409;
NumDims.x410 = max(NumDims.layer_consequent_mamdani_defs_center, NumDims.x409);

% Add:
Vars.x411 = Vars.x403 + Vars.x404;
NumDims.x411 = max(NumDims.x403, NumDims.x404);

% Mul:
Vars.x413 = Vars.x411 .* Vars.x412;
NumDims.x413 = max(NumDims.x411, NumDims.x412);

% Add:
Vars.x414 = Vars.layer_consequent_mamdani_defs_center + Vars.x413;
NumDims.x414 = max(NumDims.layer_consequent_mamdani_defs_center, NumDims.x413);

% Mul:
Vars.x416 = Vars.x403 .* Vars.x415;
NumDims.x416 = max(NumDims.x403, NumDims.x415);

% Add:
Vars.x417 = Vars.layer_consequent_mamdani_defs_center + Vars.x416;
NumDims.x417 = max(NumDims.layer_consequent_mamdani_defs_center, NumDims.x416);

% Mul:
Vars.x419 = Vars.x403 .* Vars.x418;
NumDims.x419 = max(NumDims.x403, NumDims.x418);

% Add:
Vars.x420 = Vars.layer_consequent_mamdani_defs_center + Vars.x419;
NumDims.x420 = max(NumDims.layer_consequent_mamdani_defs_center, NumDims.x419);

% Add:
Vars.x421 = Vars.x403 + Vars.x404;
NumDims.x421 = max(NumDims.x403, NumDims.x404);

% Mul:
Vars.x423 = Vars.x421 .* Vars.x422;
NumDims.x423 = max(NumDims.x421, NumDims.x422);

% Add:
Vars.x424 = Vars.layer_consequent_mamdani_defs_center + Vars.x423;
NumDims.x424 = max(NumDims.layer_consequent_mamdani_defs_center, NumDims.x423);

% Add:
Vars.x425 = Vars.x403 + Vars.x404;
NumDims.x425 = max(NumDims.x403, NumDims.x404);

% Add:
Vars.x426 = Vars.x425 + Vars.x405;
NumDims.x426 = max(NumDims.x425, NumDims.x405);

% Mul:
Vars.x428 = Vars.x426 .* Vars.x427;
NumDims.x428 = max(NumDims.x426, NumDims.x427);

% Add:
Vars.x429 = Vars.layer_consequent_mamdani_defs_center + Vars.x428;
NumDims.x429 = max(NumDims.layer_consequent_mamdani_defs_center, NumDims.x428);

% Unsqueeze:
[shape, NumDims.x430] = prepareUnsqueezeArgs(Vars.x429, Vars.UnsqueezeAxes1015, NumDims.x429);
Vars.x430 = reshape(Vars.x429, shape);

% Unsqueeze:
[shape, NumDims.x431] = prepareUnsqueezeArgs(Vars.x424, Vars.UnsqueezeAxes1016, NumDims.x424);
Vars.x431 = reshape(Vars.x424, shape);

% Unsqueeze:
[shape, NumDims.x433] = prepareUnsqueezeArgs(Vars.x414, Vars.UnsqueezeAxes1017, NumDims.x414);
Vars.x433 = reshape(Vars.x414, shape);

% Unsqueeze:
[shape, NumDims.x434] = prepareUnsqueezeArgs(Vars.x410, Vars.UnsqueezeAxes1018, NumDims.x410);
Vars.x434 = reshape(Vars.x410, shape);

% Unsqueeze:
[shape, NumDims.x435] = prepareUnsqueezeArgs(Vars.x410, Vars.UnsqueezeAxes1019, NumDims.x410);
Vars.x435 = reshape(Vars.x410, shape);

% Unsqueeze:
[shape, NumDims.x436] = prepareUnsqueezeArgs(Vars.x414, Vars.UnsqueezeAxes1020, NumDims.x414);
Vars.x436 = reshape(Vars.x414, shape);

% Unsqueeze:
[shape, NumDims.x438] = prepareUnsqueezeArgs(Vars.x424, Vars.UnsqueezeAxes1021, NumDims.x424);
Vars.x438 = reshape(Vars.x424, shape);

% Unsqueeze:
[shape, NumDims.x439] = prepareUnsqueezeArgs(Vars.x429, Vars.UnsqueezeAxes1022, NumDims.x429);
Vars.x439 = reshape(Vars.x429, shape);

% Unsqueeze:
[shape, NumDims.x440] = prepareUnsqueezeArgs(Vars.x429, Vars.UnsqueezeAxes1023, NumDims.x429);
Vars.x440 = reshape(Vars.x429, shape);

% Unsqueeze:
[shape, NumDims.x441] = prepareUnsqueezeArgs(Vars.x424, Vars.UnsqueezeAxes1024, NumDims.x424);
Vars.x441 = reshape(Vars.x424, shape);

% Unsqueeze:
[shape, NumDims.x442] = prepareUnsqueezeArgs(Vars.x420, Vars.UnsqueezeAxes1025, NumDims.x420);
Vars.x442 = reshape(Vars.x420, shape);

% Unsqueeze:
[shape, NumDims.x444] = prepareUnsqueezeArgs(Vars.x417, Vars.UnsqueezeAxes1026, NumDims.x417);
Vars.x444 = reshape(Vars.x417, shape);

% Unsqueeze:
[shape, NumDims.x445] = prepareUnsqueezeArgs(Vars.x424, Vars.UnsqueezeAxes1027, NumDims.x424);
Vars.x445 = reshape(Vars.x424, shape);

% Unsqueeze:
[shape, NumDims.x446] = prepareUnsqueezeArgs(Vars.x420, Vars.UnsqueezeAxes1028, NumDims.x420);
Vars.x446 = reshape(Vars.x420, shape);

% Unsqueeze:
[shape, NumDims.x448] = prepareUnsqueezeArgs(Vars.x417, Vars.UnsqueezeAxes1029, NumDims.x417);
Vars.x448 = reshape(Vars.x417, shape);

% Unsqueeze:
[shape, NumDims.x449] = prepareUnsqueezeArgs(Vars.x414, Vars.UnsqueezeAxes1030, NumDims.x414);
Vars.x449 = reshape(Vars.x414, shape);

% Unsqueeze:
[shape, NumDims.x450] = prepareUnsqueezeArgs(Vars.x420, Vars.UnsqueezeAxes1031, NumDims.x420);
Vars.x450 = reshape(Vars.x420, shape);

% Unsqueeze:
[shape, NumDims.x452] = prepareUnsqueezeArgs(Vars.x417, Vars.UnsqueezeAxes1032, NumDims.x417);
Vars.x452 = reshape(Vars.x417, shape);

% Unsqueeze:
[shape, NumDims.x453] = prepareUnsqueezeArgs(Vars.x414, Vars.UnsqueezeAxes1033, NumDims.x414);
Vars.x453 = reshape(Vars.x414, shape);

% Unsqueeze:
[shape, NumDims.x454] = prepareUnsqueezeArgs(Vars.x410, Vars.UnsqueezeAxes1034, NumDims.x410);
Vars.x454 = reshape(Vars.x410, shape);

% Concat:
[dim, NumDims.x455] = prepareConcatArgs(0, [NumDims.x430, NumDims.x431, NumDims.x467, NumDims.x433, NumDims.x434, NumDims.x435, NumDims.x436, NumDims.x468, NumDims.x438, NumDims.x439, NumDims.x440, NumDims.x441, NumDims.x442, NumDims.x469, NumDims.x444, NumDims.x445, NumDims.x446, NumDims.x470, NumDims.x448, NumDims.x449, NumDims.x450, NumDims.x471, NumDims.x452, NumDims.x453, NumDims.x454]);
Vars.x455 = cat(dim, Vars.x430, Vars.x431, Vars.x467, Vars.x433, Vars.x434, Vars.x435, Vars.x436, Vars.x468, Vars.x438, Vars.x439, Vars.x440, Vars.x441, Vars.x442, Vars.x469, Vars.x444, Vars.x445, Vars.x446, Vars.x470, Vars.x448, Vars.x449, Vars.x450, Vars.x471, Vars.x452, Vars.x453, Vars.x454);

% Unsqueeze:
[shape, NumDims.x456] = prepareUnsqueezeArgs(Vars.x455, Vars.UnsqueezeAxes1035, NumDims.x455);
Vars.x456 = reshape(Vars.x455, shape);

% MatMul:
[Vars.output, NumDims.output] = onnxMatMul(Vars.x402, Vars.x456, NumDims.x402, NumDims.x456);

% Set graph output arguments from Vars and NumDims:
output = Vars.output;
outputNumDims1037 = NumDims.output;
% Set output state from Vars:
state = updateStruct(state, Vars);
end

function [inputDataPerms, outputDataPerms, Training] = parseInputs(input, numDataOutputs, params, varargin)
% Function to validate inputs to ANFISFcn:
%p = inputParser;
p = feval('inputParser');
isValidArrayInput = @(x)isnumeric(x) || isstring(x);
isValidONNXParameters = @(x)isa(x, 'ONNXParameters');
%addRequired(p, 'input', isValidArrayInput);
%addRequired(p, 'params', isValidONNXParameters);
addParameter(p, 'InputDataPermutation', 'auto');
addParameter(p, 'OutputDataPermutation', 'auto');
addParameter(p, 'Training', false);
parse(p, input, params, varargin{:});
inputDataPerms = p.Results.InputDataPermutation;
outputDataPerms = p.Results.OutputDataPermutation;
Training = p.Results.Training;
if isnumeric(inputDataPerms)
    inputDataPerms = {inputDataPerms};
end
if isstring(inputDataPerms) && isscalar(inputDataPerms) || ischar(inputDataPerms)
    inputDataPerms = repmat({inputDataPerms},1,1);
end
if isnumeric(outputDataPerms)
    outputDataPerms = {outputDataPerms};
end
if isstring(outputDataPerms) && isscalar(outputDataPerms) || ischar(outputDataPerms)
    outputDataPerms = repmat({outputDataPerms},1,numDataOutputs);
end
end

function [input, Training, outputDataPerms, anyDlarrayInputs] = preprocessInput(input, params, varargin)
% Parse input arguments
[inputDataPerms, outputDataPerms, Training] = parseInputs(input, 1, params, varargin{:});
anyDlarrayInputs = any(cellfun(@(x)isa(x, 'dlarray'), {input}));
% Make the input variables into unlabelled dlarrays:
input = makeUnlabeledDlarray(input);
% Permute inputs if requested:
input = permuteInputVar(input, inputDataPerms{1}, 2);
% Check input size(s):
checkInputSize(size(input), {'batch_size' 3}, "input");
end

function [output] = postprocessOutput(output, outputDataPerms, anyDlarrayInputs, Training, varargin)
% Set output type:
if ~anyDlarrayInputs && ~Training
    output = extractdata(output);
end
% Permute outputs if requested:
output = permuteOutputVar(output, outputDataPerms{1}, 2);
end


%% dlarray functions implementing ONNX operators:

function [Y, numDimsY] = onnxConstantOfShape(value, ONNXShape)
% Returns a DLT tensor with the reverse of the ONNXShape.
DLTShape = fliplr(extractdata(ONNXShape(:)'));
numDimsY = numel(DLTShape);
switch numDimsY
    case 0
        % If shape is empty, output is a scalar
        Y = value;
    case 1
        Y = ones(DLTShape,1) .* value;
    otherwise
        Y = ones(DLTShape) .* value;
end
end

function [Y, numDimsY] = onnxGather(X, ONNXIdx, ONNXAxis, numDimsX, numDimsIdx)
% Function implementing the ONNX Gather operator

% In ONNX, 'Gather' first indexes into dimension ONNXAxis of data, using
% the contents of ONNXIdx as the indices. Then, it reshapes the ONNXAxis
% into the shape of ONNXIdx.
%   Example 1:
% Suppose data has shape [2 3 4 5], ONNXIdx has shape [6 7], and axis=1.
% The result has shape [2 6 7 4 5].
%   Example 2:
% Suppose data has shape [2 3 4 5], ONNXIdx has shape [6], and axis=1.
% The result has shape [2 6 4 5].
%   Example 3:
% Suppose data has shape [2 3 4 5], ONNXIdx has shape [] (a scalar), and axis=1.
% The result has shape [2 4 5].
%
% Since we're using reverse indexing relative to ONNX, in this function
% data and ONNXIdx both have reversed dimension ordering.
numDimsY = numDimsIdx + (numDimsX - 1);
if isempty(X)
    Y = X;
    return;
end
% (1) First, do the subsref part of Gather
if ONNXAxis<0
    ONNXAxis = ONNXAxis + numDimsX;                                 % Axis can be negative. Convert it to its positive equivalent.
end
% ONNXIdx is origin-0 in ONNX, so add 1
mlIdx  = extractdata(ONNXIdx) + 1;
% Convert axis to DLT. ONNXAxis is origin 0 and we index from the end
mlAxis = numDimsX - ONNXAxis;
% Use subsref to index into data
Indices.subs = repmat({':'}, 1, numDimsX);
Indices.subs{mlAxis} = mlIdx(:);                                          % Index as a column to ensure the output is 1-D in the indexed dimension (for now).
Indices.type = '()';
Y = subsref(X, Indices);
% (2) Now do the reshaping part of Gather
shape = size(Y, 1:numDimsX);
if numDimsIdx == 0
    % Delete the indexed dimension
    shape(mlAxis) = [];
elseif numDimsIdx > 1
    % Reshape the indexed dimension into the shape of ONNXIdx
    shape = [shape(1:mlAxis-1) size(ONNXIdx, 1:numDimsIdx) shape(mlAxis+1:end)];
end
% Extend the shape to 2D so it's valid MATLAB
if numel(shape) < 2
    shape = [shape ones(1,2-numel(shape))];
end
Y = reshape(Y, shape);
end

function [D, numDimsD] = onnxMatMul(A, B, numDimsA, numDimsB)
% Implements the ONNX MatMul operator.

% If either arg is more than 2D, loop over all dimensions before the final
% 2. Inside the loop, perform matrix multiplication.

% If B is 1-D, temporarily extend it to a row vector
if numDimsB==1
    B = B(:)';
end
maxNumDims = max(numDimsA, numDimsB);
numDimsD = maxNumDims;
if maxNumDims > 2
    % sizes of matrices to be multiplied
    matSizeA        = size(A, 1:2);
    matSizeB        = size(B, 1:2);
    % size of the stack of matrices
    stackSizeA      = size(A, 3:maxNumDims);
    stackSizeB      = size(B, 3:maxNumDims);
    % final stack size
    resultStackSize = max(stackSizeA, stackSizeB);
    % full implicitly-expanded sizes
    fullSizeA       = [matSizeA resultStackSize];
    fullSizeB       = [matSizeB resultStackSize];
    resultSize      = [matSizeB(1) matSizeA(2) resultStackSize];
    % Repmat A and B up to the full stack size using implicit expansion
    A = A + zeros(fullSizeA);
    B = B + zeros(fullSizeB);
    % Reshape A and B to flatten the stack dims (all dims after the first 2)
    A2 = reshape(A, size(A,1), size(A,2), []);
    B2 = reshape(B, size(B,1), size(B,2), []);
    % Iterate down the stack dim, doing the 2d matrix multiplications
    D2 = zeros([matSizeB(1), matSizeA(2), size(A2,3)], 'like', A);
    for i = size(A2,3):-1:1
        D2(:,:,i) = B2(:,:,i) * A2(:,:,i);
    end
    % Reshape D2 to the result size (unflatten the stack dims)
    D = reshape(D2, resultSize);
else
    D = B * A;
    if numDimsA==1 || numDimsB==1
        D = D(:);
        numDimsD = 1;
    end
end
end

function [Y, numDimsY] = onnxShape(X, numDimsX)
% Implements the ONNX Shape operator
% Return the reverse ONNX shape as a 1D column vector
switch numDimsX
    case 0
        if isempty(X)
            Y = dlarray(0);
        else
            Y = dlarray(1);
        end
    case 1
        if isempty(X)
            Y = dlarray(0);
        else
            Y = dlarray(size(X,1));
        end
    otherwise
        Y = dlarray(fliplr(size(X, 1:numDimsX))');
end
numDimsY = 1;
end

function [Y, numDimsY] = onnxSqueeze(X, ONNXAxes, numDimsX)
% Implements the ONNX Squeeze operator
if numDimsX == 0
    Y = X;
    numDimsY = numDimsX;
else
    % Find the new ONNX shape
    curOShape = size(X, numDimsX:-1:1);
    if isempty(ONNXAxes)
        newOShape = curOShape(curOShape ~= 1);
    else
        ONNXAxes(ONNXAxes<0) = ONNXAxes(ONNXAxes<0) + numDimsX;
        newOShape = curOShape;
        newOShape(ONNXAxes+1) = [];
    end
    % Get numDimsY from ONNX shape
    numDimsY  = numel(newOShape);
    newMShape = [fliplr(newOShape) ones(1, 2-numDimsY)];    % Append 1's to shape if numDims<2
    Y         = reshape(X, newMShape);
end
end

function [output, numDimsOutput] = onnxWhere(condition, X, Y, numDimsCondition, numDimsX, numDimsY)
bigz = zeros(size(condition + X + Y));      % broadcast
condition = condition + bigz;
X = X + bigz;
output = Y + bigz;
output(condition==1) = X(condition==1);
numDimsOutput = max([numDimsCondition, numDimsX, numDimsY]);
end

function [DLTAxis, numDimsY] = prepareConcatArgs(ONNXAxis, numDimsXs)
% Prepares arguments for implementing the ONNX Concat operator
numDimsY = numDimsXs(1);
if ONNXAxis<0
    ONNXAxis = ONNXAxis + numDimsY;
end
DLTAxis = numDimsY - ONNXAxis;
end

function [shape, numDimsY] = prepareExpandArgs(ONNXShape)
% Prepares arguments for implementing the ONNX Expand operator

% Broadcast X to ONNXShape. The shape of X must be compatible with ONNXShape.
ONNXShape = extractdata(ONNXShape);
shape = fliplr(ONNXShape(:)');
if numel(shape) < 2
    shape = [shape ones(1, 2-numel(shape))];
end
numDimsY = numel(ONNXShape);
end

function [dim1, dim2, numDimsY] = prepareFlattenArgs(X, ONNXAxis, numDimsX)
% Prepares arguments for implementing the ONNX Flatten operator

% ONNXAxis is the number of dimensions that go on the left in ONNX, so here
% it is the number of dimensions that go on the right.
if ONNXAxis < 0
    ONNXAxis = ONNXAxis + numDimsX;
end
if ONNXAxis == 0
    dim2 = 1;
else
    dim2 = prod(size(X, numDimsX+1-ONNXAxis:numDimsX));     % numel on the right
end
dim1 = numel(X)/dim2;                                   % numel on the left
numDimsY = 2;
end

function dims = prepareReduceArgs(ONNXAxes, numDimsX)
% Prepares arguments for implementing the ONNX Reduce operator
if isempty(ONNXAxes)
    ONNXAxes = 0:numDimsX-1;   % All axes
end
ONNXAxes(ONNXAxes<0) = ONNXAxes(ONNXAxes<0) + numDimsX;
dims = numDimsX - ONNXAxes;
end

function [DLTShape, numDimsY] = prepareReshapeArgs(X, ONNXShape, numDimsX)
% Prepares arguments for implementing the ONNX Reshape operator
ONNXShape = flip(extractdata(ONNXShape));            % First flip the shape to make it correspond to the dimensions of X.
% In ONNX, 0 means "unchanged", and -1 means "infer". In DLT, there is no
% "unchanged", and [] means "infer".
DLTShape = num2cell(ONNXShape);                      % Make a cell array so we can include [].
% Replace zeros with the actual size
if any(ONNXShape==0)
    i0 = find(ONNXShape==0);
    DLTShape(i0) = num2cell(size(X, numDimsX - numel(ONNXShape) + i0));  % right-align the shape vector and dims
end
if any(ONNXShape == -1)
    % Replace -1 with []
    i = ONNXShape == -1;
    DLTShape{i} = [];
end
if numel(DLTShape)==1
    DLTShape = [DLTShape 1];
end
numDimsY = numel(ONNXShape);
end

function [S, numDimsY] = prepareSliceArgs(X, Starts, Ends, Axes, Steps, numDimsX)
% Prepares arguments for implementing the ONNX Slice operator

% Starts, Ends and Axes are all origin 0. Axes refer to the ONNX dimension
% ordering, but X uses the reverse, DLT ordering. Starts, Ends, Axes, and
% Steps correspond positionally. Axes and Steps may be omitted, with
% defaults described in the ONNX spec.

% Set default Axes and Steps if not supplied
if isempty(Axes)
    Axes = 0:numDimsX-1;   % All axes
end
Axes(Axes<0) = Axes(Axes<0) + numDimsX; % Handle negative Axes.
if isempty(Steps)
    Steps = ones(1, numel(Starts));
end
% Init all dims to :
S.subs = repmat({':'}, 1, numDimsX);
S.type = '()';
% Set Starts and Ends for each axis
for i = 1:numel(Axes)
    DLTDim = numDimsX - Axes(i);                                               % The DLT dim is the reverse of the ONNX dim.
    % "If a negative value is passed for any of the start or end indices,
    % it represents number of elements before the end of that dimension."
    if Starts(i) < 0
        Starts(i) = size(X,DLTDim) + Starts(i);
    end
    if Ends(i) < 0
        Ends(i) = max(-1, size(X,DLTDim) + Ends(i));                        % The -1 case is when we're slicing backward and want to include 0.
    end
    % "If the value passed to start or end is larger than the n (the number
    % of elements in this dimension), it represents n."
    if Starts(i) > size(X,DLTDim)
        Starts(i) = size(X,DLTDim);
    end
    if Ends(i) > size(X,DLTDim)
        Ends(i) = size(X,DLTDim);
    end
    if Steps(i) > 0
        S.subs{DLTDim} = 1 + (Starts(i) : Steps(i) : Ends(i)-1);            % 1 + (Origin 0 indexing with end index excluded)
    else
        S.subs{DLTDim} = 1 + (Starts(i) : Steps(i) : Ends(i)+1);            % 1 + (Origin 0 indexing with end index excluded)
    end
end
numDimsY = numDimsX;
end

function [perm, numDimsA] = prepareTransposeArgs(ONNXPerm, numDimsA)
% Prepares arguments for implementing the ONNX Transpose operator
if numDimsA <= 1        % Tensors of numDims 0 or 1 are unchanged by ONNX Transpose.
    perm = [];
else
    if isempty(ONNXPerm)        % Empty ONNXPerm means reverse the dimensions.
        perm = numDimsA:-1:1;
    else
        perm = numDimsA-flip(ONNXPerm);
    end
end
end

function [newShape, numDimsY] = prepareUnsqueezeArgs(X, ONNXAxes, numDimsX)
% Prepares arguments for implementing the ONNX Unsqueeze operator

% ONNX axes are origin 0
ONNXAxes = extractdata(ONNXAxes);
ONNXAxes(ONNXAxes<0) = ONNXAxes(ONNXAxes<0) + numDimsX;
ONNXAxes = sort(ONNXAxes);                                              % increasing order
numDimsY = numDimsX + numel(ONNXAxes);
if numDimsY == 1
    newShape = size(X);
else
    DLTAxes  = flip(numDimsY - ONNXAxes);                                  % increasing order
    newShape = ones(1, numDimsY);
    posToSet = setdiff(1:numDimsY, DLTAxes, 'stable');
    newShape(posToSet) = size(X, 1:numel(posToSet));
end
end

%% Utility functions:

function s = appendStructs(varargin)
% s = appendStructs(s1, s2,...). Assign all fields in s1, s2,... into s.
if isempty(varargin)
    s = struct;
else
    s = varargin{1};
    for i = 2:numel(varargin)
        fromstr = varargin{i};
        fs = fieldnames(fromstr);
        for j = 1:numel(fs)
            s.(fs{j}) = fromstr.(fs{j});
        end
    end
end
end

function checkInputSize(inputShape, expectedShape, inputName)

if numel(expectedShape)==0
    % The input is a scalar
    if ~isequal(inputShape, [1 1])
        inputSizeStr = makeSizeString(inputShape);
        error(message('nnet_cnn_onnx:onnx:InputNeedsResize',inputName, "[1,1]", inputSizeStr));
    end
elseif numel(expectedShape)==1
    % The input is a vector
    if ~shapeIsColumnVector(inputShape) || ~iSizesMatch({inputShape(1)}, expectedShape)
        expectedShape{2} = 1;
        expectedSizeStr = makeSizeString(expectedShape);
        inputSizeStr = makeSizeString(inputShape);
        error(message('nnet_cnn_onnx:onnx:InputNeedsResize',inputName, expectedSizeStr, inputSizeStr));
    end
else
    % The input has 2 dimensions or more
    
    % The input dimensions have been reversed; flip them back to compare to the
    % expected ONNX shape.
    inputShape = fliplr(inputShape);
    
    % If the expected shape has fewer dims than the input shape, error.
    if numel(expectedShape) < numel(inputShape)
        expectedSizeStr = strjoin(["[", strjoin(string(expectedShape), ","), "]"], "");
        error(message('nnet_cnn_onnx:onnx:InputHasGreaterNDims', inputName, expectedSizeStr));
    end
    
    % Prepad the input shape with trailing ones up to the number of elements in
    % expectedShape
    inputShape = num2cell([ones(1, numel(expectedShape) - length(inputShape)) inputShape]);
    
    % Find the number of variable size dimensions in the expected shape
    numVariableInputs = sum(cellfun(@(x) isa(x, 'char') || isa(x, 'string'), expectedShape));
    
    % Find the number of input dimensions that are not in the expected shape
    % and cannot be represented by a variable dimension
    nonMatchingInputDims = setdiff(string(inputShape), string(expectedShape));
    numNonMatchingInputDims  = numel(nonMatchingInputDims) - numVariableInputs;
    
    expectedSizeStr = makeSizeString(expectedShape);
    inputSizeStr = makeSizeString(inputShape);
    if numNonMatchingInputDims == 0 && ~iSizesMatch(inputShape, expectedShape)
        % The actual and expected input dimensions match, but in
        % a different order. The input needs to be permuted.
        error(message('nnet_cnn_onnx:onnx:InputNeedsPermute',inputName, expectedSizeStr, inputSizeStr));
    elseif numNonMatchingInputDims > 0
        % The actual and expected input sizes do not match.
        error(message('nnet_cnn_onnx:onnx:InputNeedsResize',inputName, expectedSizeStr, inputSizeStr));
    end
end
end

function doesMatch = iSizesMatch(inputShape, expectedShape)
% Check whether the input and expected shapes match, in order.
% Size elements match if (1) the elements are equal, or (2) the expected
% size element is a variable (represented by a character vector or string)
doesMatch = true;
for i=1:numel(inputShape)
    if ~(isequal(inputShape{i},expectedShape{i}) || ischar(expectedShape{i}) || isstring(expectedShape{i}))
        doesMatch = false;
        return
    end
end
end

function sizeStr = makeSizeString(shape)
sizeStr = strjoin(["[", strjoin(string(shape), ","), "]"], "");
end

function isVec = shapeIsColumnVector(shape)
if numel(shape) == 2 && shape(2) == 1
    isVec = true;
else
    isVec = false;
end
end
function X = makeUnlabeledDlarray(X)
% Make numeric X into an unlabelled dlarray
if isa(X, 'dlarray')
    X = stripdims(X);
elseif isnumeric(X)
    if ~(isa(X,'single') || isa(X,'double'))
        % Make ints double so they can combine with anything without
        % reducting precision
        X = double(X);
    end
    X = dlarray(X);
end
end

function [Vars, NumDims] = packageVariables(params, inputNames, inputValues, inputNumDims)
% inputNames, inputValues are cell arrays. inputRanks is a numeric vector.
Vars = appendStructs(params.Learnables, params.Nonlearnables, params.State);
NumDims = params.NumDimensions;
% Add graph inputs
for i = 1:numel(inputNames)
    Vars.(inputNames{i}) = inputValues{i};
    NumDims.(inputNames{i}) = inputNumDims(i);
end
end

function X = permuteInputVar(X, userDataPerm, onnxNDims)
% Returns reverse-ONNX ordering
if onnxNDims == 0
    return;
elseif onnxNDims == 1 && isvector(X)
    X = X(:);
    return;
elseif isnumeric(userDataPerm)
    % Permute into reverse ONNX ordering
    perm = fliplr(userDataPerm);
elseif isequal(userDataPerm, 'auto') && onnxNDims == 4
    % Permute MATLAB HWCN to reverse onnx (WHCN)
    perm = [2 1 3 4];
else
    % userDataPerm is either 'none' or 'auto' with no default, which means
    % it's already in onnx ordering, so just make it reverse onnx
    perm = max(2,onnxNDims):-1:1;
end
X = permute(X, perm);
end
function Y = permuteOutputVar(Y, userDataPerm, onnxNDims)
switch onnxNDims
    case 0
        perm = [];
    case 1
        if isnumeric(userDataPerm)
            % Use the user's permutation because Y is a column vector which
            % already matches ONNX.
            perm = userDataPerm;
        elseif isequal(userDataPerm, 'auto')
            % Treat the 1D onnx vector as a 2D column and transpose it
            perm = [2 1];
        else
            % userDataPerm is 'none'. Leave Y alone because it already
            % matches onnx.
            perm = [];
        end
    otherwise
        % ndims >= 2
        if isnumeric(userDataPerm)
            % Use the inverse of the user's permutation. This is not just the
            % flip of the permutation vector.
            perm = onnxNDims + 1 - userDataPerm;
        elseif isequal(userDataPerm, 'auto')
            if onnxNDims == 2
                % Permute reverse ONNX CN to DLT CN (do nothing)
                perm = [];
            elseif onnxNDims == 4
                % Permute reverse onnx (WHCN) to MATLAB HWCN
                perm = [2 1 3 4];
            else
                % User wants the output in ONNX ordering, so just reverse it from
                % reverse onnx
                perm = onnxNDims:-1:1;
            end
        else
            % userDataPerm is 'none', so just make it reverse onnx
            perm = onnxNDims:-1:1;
        end
end
if ~isempty(perm)
    Y = permute(Y, perm);
end
end

function s = updateStruct(s, t)
% Set all existing fields in s from fields in t, ignoring extra fields in t.
for name = transpose(fieldnames(s))
    s.(name{1}) = t.(name{1});
end
end
