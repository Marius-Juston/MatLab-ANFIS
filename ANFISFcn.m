function [output, state] = ANFISFcn(input, params, varargin)
%ANFISFCN Function implementing an imported ONNX network.
%
% THIS FILE WAS AUTO-GENERATED BY importONNXFunction.
% ONNX Operator Set Version: 9
%
% Variable names in this function are taken from the original ONNX file.
%
% [OUTPUT] = ANFISFcn(INPUT, PARAMS)
%			- Evaluates the imported ONNX network ANFISFCN with input(s)
%			INPUT and the imported network parameters in PARAMS. Returns
%			network output(s) in OUTPUT.
%
% [OUTPUT, STATE] = ANFISFcn(INPUT, PARAMS)
%			- Additionally returns state variables in STATE. When training,
%			use this form and set TRAINING to true.
%
% [__] = ANFISFcn(INPUT, PARAMS, 'NAME1', VAL1, 'NAME2', VAL2, ...)
%			- Specifies additional name-value pairs described below:
%
% 'Training'
% 			Boolean indicating whether the network is being evaluated for
%			prediction or training. If TRAINING is true, state variables
%			will be updated.
%
% 'InputDataPermutation'
%			'auto' - Automatically attempt to determine the permutation
%			 between the dimensions of the input data and the dimensions of
%			the ONNX model input. For example, the permutation from HWCN
%			(MATLAB standard) to NCHW (ONNX standard) uses the vector
%			[4 3 1 2]. See the documentation for IMPORTONNXFUNCTION for
%			more information about automatic permutation.
%
%			'none' - Input(s) are passed in the ONNX model format. See 'Inputs'.
%
%			numeric vector - The permutation vector describing the
%			transformation between input data dimensions and the expected
%			ONNX input dimensions.%
%			cell array - If the network has multiple inputs, each cell
%			contains 'auto', 'none', or a numeric vector.
%
% 'OutputDataPermutation'
%			'auto' - Automatically attempt to determine the permutation
%			between the dimensions of the output and a conventional MATLAB
%			dimension ordering. For example, the permutation from NC (ONNX
%			standard) to CN (MATLAB standard) uses the vector [2 1]. See
%			the documentation for IMPORTONNXFUNCTION for more information
%			about automatic permutation.
%
%			'none' - Return output(s) as given by the ONNX model. See 'Outputs'.
%
%			numeric vector - The permutation vector describing the
%			transformation between the ONNX output dimensions and the
%			desired output dimensions.%
%			cell array - If the network has multiple outputs, each cell
%			contains 'auto', 'none' or a numeric vector.
%
% Inputs:
% -------
% INPUT
%			- Input(s) to the ONNX network.
%			  The input size(s) expected by the ONNX file are:
%				  INPUT:		[batch_size, 3]				Type: FLOAT
%			  By default, the function will try to permute the input(s)
%			  into this dimension ordering. If the default is incorrect,
%			  use the 'InputDataPermutation' argument to control the
%			  permutation.
%
%
% PARAMS	- Network parameters returned by 'importONNXFunction'.
%
%
% Outputs:
% --------
% OUTPUT
%			- Output(s) of the ONNX network.
%			  Without permutation, the size(s) of the outputs are:
%				  OUTPUT:		[batch_size, 1]				Type: FLOAT
%			  By default, the function will try to permute the output(s)
%			  from this dimension ordering into a conventional MATLAB
%			  ordering. If the default is incorrect, use the
%			  'OutputDataPermutation' argument to control the permutation.
%
% STATE		- (Optional) State variables. When TRAINING is true, these will
% 			  have been updated from the original values in PARAMS.State.
%
%
%  See also importONNXFunction

% Preprocess the input data and arguments:
[input, Training, outputDataPerms, anyDlarrayInputs] = preprocessInput(input, params, varargin{:});
% Put all variables into a single struct to implement dynamic scoping:
[Vars, NumDims] = packageVariables(params, {'input'}, {input}, [2]);
% Call the top-level graph function:
[output, NumDims.output, state] = torch_jit_exportGraph1000(input, NumDims.input, Vars, NumDims, Training, params.State);
% Postprocess the output data
[output] = postprocessOutput(output, outputDataPerms, anyDlarrayInputs, Training, varargin{:});
end

function [output, outputNumDims1037, state] = torch_jit_exportGraph1000(input, inputNumDims1036, Vars, NumDims, Training, state)
% Function implementing the graph 'torch_jit_exportGraph1000'
% Update Vars and NumDims from the graph's formal input parameters. Note that state variables are already in Vars.
Vars.input = input;
NumDims.input = inputNumDims1036;

% Execute the operators:
% Slice:
[Indices, NumDims.x14] = prepareSliceArgs(Vars.input, [0], [1], [1], [], NumDims.input);
Vars.x14 = subsref(Vars.input, Indices);

% Abs:
Vars.x17 = abs(Vars.x446);
NumDims.x17 = NumDims.x446;

% Add:
Vars.x19 = Vars.x17 + Vars.x18;
NumDims.x19 = max(NumDims.x17, NumDims.x18);

% Div:
Vars.x21 = Vars.x20 ./ Vars.x19;
NumDims.x21 = max(NumDims.x20, NumDims.x19);

% Abs:
Vars.x22 = abs(Vars.layer_fuzzify_varmfs_distance_center_width);
NumDims.x22 = NumDims.layer_fuzzify_varmfs_distance_center_width;

% Abs:
Vars.x23 = abs(Vars.layer_fuzzify_varmfs_distance_side_width);
NumDims.x23 = NumDims.layer_fuzzify_varmfs_distance_side_width;

% Sub:
Vars.x25 = Vars.x14 - Vars.x24;
NumDims.x25 = max(NumDims.x14, NumDims.x24);

% Shape:
[Vars.x26, NumDims.x26] = onnxShape(Vars.x25, NumDims.x25);

% ConstantOfShape:
[Vars.x27, NumDims.x27] = onnxConstantOfShape(Vars.ConstantOfShapeValue1001, Vars.x26);

% Shape:
[Vars.x28, NumDims.x28] = onnxShape(Vars.x25, NumDims.x25);

% ConstantOfShape:
[Vars.x29, NumDims.x29] = onnxConstantOfShape(Vars.ConstantOfShapeValue1002, Vars.x28);

% Abs:
Vars.x30 = abs(Vars.x25);
NumDims.x30 = NumDims.x25;

% Div:
Vars.x33 = Vars.x22 ./ Vars.x447;
NumDims.x33 = max(NumDims.x22, NumDims.x447);

% Greater:
Vars.x34 = Vars.x30 > Vars.x33;
NumDims.x34 = max(NumDims.x30, NumDims.x33);

% Not:
Vars.x35 = not(Vars.x34);
NumDims.x35 = NumDims.x34;

% Add:
Vars.x36 = Vars.x33 + Vars.x21;
NumDims.x36 = max(NumDims.x33, NumDims.x21);

% Greater:
Vars.x37 = Vars.x30 > Vars.x36;
NumDims.x37 = max(NumDims.x30, NumDims.x36);

% Not:
Vars.x38 = not(Vars.x37);
NumDims.x38 = NumDims.x37;

% Not:
Vars.x39 = not(Vars.x35);
NumDims.x39 = NumDims.x35;

% Cast:
Vars.x40 = logical(Vars.x39);
NumDims.x40 = NumDims.x39;

% Cast:
Vars.x41 = logical(Vars.x38);
NumDims.x41 = NumDims.x38;

% And:
Vars.x42 = Vars.x40 & Vars.x41;
NumDims.x42 = max(NumDims.x40, NumDims.x41);

% Cast:
Vars.x43 = logical(Vars.x42);
NumDims.x43 = NumDims.x42;

% Neg:
Vars.x44 = -(Vars.x19);
NumDims.x44 = NumDims.x19;

% Sub:
Vars.x45 = Vars.x30 - Vars.x33;
NumDims.x45 = max(NumDims.x30, NumDims.x33);

% Mul:
Vars.x46 = Vars.x44 .* Vars.x45;
NumDims.x46 = max(NumDims.x44, NumDims.x45);

% Add:
Vars.x48 = Vars.x46 + Vars.x47;
NumDims.x48 = max(NumDims.x46, NumDims.x47);

% Where:
[Vars.x49, NumDims.x49] = onnxWhere(Vars.x43, Vars.x48, Vars.x29, NumDims.x43, NumDims.x48, NumDims.x29);

% Where:
[Vars.x50, NumDims.x50] = onnxWhere(Vars.x35, Vars.x27, Vars.x49, NumDims.x35, NumDims.x27, NumDims.x49);

% Div:
Vars.x53 = Vars.x23 ./ Vars.x448;
NumDims.x53 = max(NumDims.x23, NumDims.x448);

% Add:
Vars.x54 = Vars.x33 + Vars.x53;
NumDims.x54 = max(NumDims.x33, NumDims.x53);

% Add:
Vars.x55 = Vars.x54 + Vars.x21;
NumDims.x55 = max(NumDims.x54, NumDims.x21);

% Mul:
Vars.x56 = Vars.x19 .* Vars.x53;
NumDims.x56 = max(NumDims.x19, NumDims.x53);

% Add:
Vars.x58 = Vars.x56 + Vars.x57;
NumDims.x58 = max(NumDims.x56, NumDims.x57);

% Add:
Vars.x59 = Vars.x25 + Vars.x55;
NumDims.x59 = max(NumDims.x25, NumDims.x55);

% Abs:
Vars.x60 = abs(Vars.x59);
NumDims.x60 = NumDims.x59;

% Greater:
Vars.x61 = Vars.x60 > Vars.x53;
NumDims.x61 = max(NumDims.x60, NumDims.x53);

% Not:
Vars.x62 = not(Vars.x61);
NumDims.x62 = NumDims.x61;

% Add:
Vars.x63 = Vars.x53 + Vars.x21;
NumDims.x63 = max(NumDims.x53, NumDims.x21);

% Greater:
Vars.x64 = Vars.x60 > Vars.x63;
NumDims.x64 = max(NumDims.x60, NumDims.x63);

% Not:
Vars.x65 = not(Vars.x64);
NumDims.x65 = NumDims.x64;

% Not:
Vars.x66 = not(Vars.x62);
NumDims.x66 = NumDims.x62;

% Cast:
Vars.x67 = logical(Vars.x66);
NumDims.x67 = NumDims.x66;

% Cast:
Vars.x68 = logical(Vars.x65);
NumDims.x68 = NumDims.x65;

% And:
Vars.x69 = Vars.x67 & Vars.x68;
NumDims.x69 = max(NumDims.x67, NumDims.x68);

% Cast:
Vars.x70 = logical(Vars.x69);
NumDims.x70 = NumDims.x69;

% Neg:
Vars.x71 = -(Vars.x19);
NumDims.x71 = NumDims.x19;

% Mul:
Vars.x72 = Vars.x71 .* Vars.x60;
NumDims.x72 = max(NumDims.x71, NumDims.x60);

% Add:
Vars.x73 = Vars.x72 + Vars.x58;
NumDims.x73 = max(NumDims.x72, NumDims.x58);

% Where:
[Vars.x74, NumDims.x74] = onnxWhere(Vars.x70, Vars.x73, Vars.x29, NumDims.x70, NumDims.x73, NumDims.x29);

% Where:
[Vars.x75, NumDims.x75] = onnxWhere(Vars.x62, Vars.x27, Vars.x74, NumDims.x62, NumDims.x27, NumDims.x74);

% Sub:
Vars.x76 = Vars.x25 - Vars.x55;
NumDims.x76 = max(NumDims.x25, NumDims.x55);

% Abs:
Vars.x77 = abs(Vars.x76);
NumDims.x77 = NumDims.x76;

% Greater:
Vars.x78 = Vars.x77 > Vars.x53;
NumDims.x78 = max(NumDims.x77, NumDims.x53);

% Not:
Vars.x79 = not(Vars.x78);
NumDims.x79 = NumDims.x78;

% Add:
Vars.x80 = Vars.x53 + Vars.x21;
NumDims.x80 = max(NumDims.x53, NumDims.x21);

% Greater:
Vars.x81 = Vars.x77 > Vars.x80;
NumDims.x81 = max(NumDims.x77, NumDims.x80);

% Not:
Vars.x82 = not(Vars.x81);
NumDims.x82 = NumDims.x81;

% Not:
Vars.x83 = not(Vars.x79);
NumDims.x83 = NumDims.x79;

% Cast:
Vars.x84 = logical(Vars.x83);
NumDims.x84 = NumDims.x83;

% Cast:
Vars.x85 = logical(Vars.x82);
NumDims.x85 = NumDims.x82;

% And:
Vars.x86 = Vars.x84 & Vars.x85;
NumDims.x86 = max(NumDims.x84, NumDims.x85);

% Cast:
Vars.x87 = logical(Vars.x86);
NumDims.x87 = NumDims.x86;

% Neg:
Vars.x88 = -(Vars.x19);
NumDims.x88 = NumDims.x19;

% Mul:
Vars.x89 = Vars.x88 .* Vars.x77;
NumDims.x89 = max(NumDims.x88, NumDims.x77);

% Add:
Vars.x90 = Vars.x89 + Vars.x58;
NumDims.x90 = max(NumDims.x89, NumDims.x58);

% Where:
[Vars.x91, NumDims.x91] = onnxWhere(Vars.x87, Vars.x90, Vars.x29, NumDims.x87, NumDims.x90, NumDims.x29);

% Where:
[Vars.x92, NumDims.x92] = onnxWhere(Vars.x79, Vars.x27, Vars.x91, NumDims.x79, NumDims.x27, NumDims.x91);

% Add:
Vars.x93 = Vars.x33 + Vars.x23;
NumDims.x93 = max(NumDims.x33, NumDims.x23);

% Mul:
Vars.x95 = Vars.x21 .* Vars.x94;
NumDims.x95 = max(NumDims.x21, NumDims.x94);

% Add:
Vars.x96 = Vars.x93 + Vars.x95;
NumDims.x96 = max(NumDims.x93, NumDims.x95);

% Mul:
Vars.x97 = Vars.x19 .* Vars.x21;
NumDims.x97 = max(NumDims.x19, NumDims.x21);

% Neg:
Vars.x98 = -(Vars.x25);
NumDims.x98 = NumDims.x25;

% Sub:
Vars.x99 = Vars.x98 - Vars.x96;
NumDims.x99 = max(NumDims.x98, NumDims.x96);

% Greater:
Vars.x101 = Vars.x99 > Vars.x100;
NumDims.x101 = max(NumDims.x99, NumDims.x100);

% Neg:
Vars.x102 = -(Vars.x21);
NumDims.x102 = NumDims.x21;

% Less:
Vars.x103 = Vars.x99 < Vars.x102;
NumDims.x103 = max(NumDims.x99, NumDims.x102);

% Not:
Vars.x104 = not(Vars.x103);
NumDims.x104 = NumDims.x103;

% Not:
Vars.x105 = not(Vars.x101);
NumDims.x105 = NumDims.x101;

% Cast:
Vars.x106 = logical(Vars.x105);
NumDims.x106 = NumDims.x105;

% Cast:
Vars.x107 = logical(Vars.x104);
NumDims.x107 = NumDims.x104;

% And:
Vars.x108 = Vars.x106 & Vars.x107;
NumDims.x108 = max(NumDims.x106, NumDims.x107);

% Cast:
Vars.x109 = logical(Vars.x108);
NumDims.x109 = NumDims.x108;

% Mul:
Vars.x110 = Vars.x19 .* Vars.x99;
NumDims.x110 = max(NumDims.x19, NumDims.x99);

% Add:
Vars.x111 = Vars.x110 + Vars.x97;
NumDims.x111 = max(NumDims.x110, NumDims.x97);

% Where:
[Vars.x112, NumDims.x112] = onnxWhere(Vars.x109, Vars.x111, Vars.x29, NumDims.x109, NumDims.x111, NumDims.x29);

% Where:
[Vars.x113, NumDims.x113] = onnxWhere(Vars.x101, Vars.x27, Vars.x112, NumDims.x101, NumDims.x27, NumDims.x112);

% Sub:
Vars.x114 = Vars.x25 - Vars.x96;
NumDims.x114 = max(NumDims.x25, NumDims.x96);

% Greater:
Vars.x116 = Vars.x114 > Vars.x115;
NumDims.x116 = max(NumDims.x114, NumDims.x115);

% Neg:
Vars.x117 = -(Vars.x21);
NumDims.x117 = NumDims.x21;

% Less:
Vars.x118 = Vars.x114 < Vars.x117;
NumDims.x118 = max(NumDims.x114, NumDims.x117);

% Not:
Vars.x119 = not(Vars.x118);
NumDims.x119 = NumDims.x118;

% Not:
Vars.x120 = not(Vars.x116);
NumDims.x120 = NumDims.x116;

% Cast:
Vars.x121 = logical(Vars.x120);
NumDims.x121 = NumDims.x120;

% Cast:
Vars.x122 = logical(Vars.x119);
NumDims.x122 = NumDims.x119;

% And:
Vars.x123 = Vars.x121 & Vars.x122;
NumDims.x123 = max(NumDims.x121, NumDims.x122);

% Cast:
Vars.x124 = logical(Vars.x123);
NumDims.x124 = NumDims.x123;

% Mul:
Vars.x125 = Vars.x19 .* Vars.x114;
NumDims.x125 = max(NumDims.x19, NumDims.x114);

% Add:
Vars.x126 = Vars.x125 + Vars.x97;
NumDims.x126 = max(NumDims.x125, NumDims.x97);

% Where:
[Vars.x127, NumDims.x127] = onnxWhere(Vars.x124, Vars.x126, Vars.x29, NumDims.x124, NumDims.x126, NumDims.x29);

% Where:
[Vars.x128, NumDims.x128] = onnxWhere(Vars.x116, Vars.x27, Vars.x127, NumDims.x116, NumDims.x27, NumDims.x127);

% Concat:
[dim, NumDims.x129] = prepareConcatArgs(1, [NumDims.x113, NumDims.x75, NumDims.x50, NumDims.x92, NumDims.x128]);
Vars.x129 = cat(dim, Vars.x113, Vars.x75, Vars.x50, Vars.x92, Vars.x128);

% Slice:
[Indices, NumDims.x130] = prepareSliceArgs(Vars.input, [1], [2], [1], [], NumDims.input);
Vars.x130 = subsref(Vars.input, Indices);

% Abs:
Vars.x133 = abs(Vars.x449);
NumDims.x133 = NumDims.x449;

% Add:
Vars.x135 = Vars.x133 + Vars.x134;
NumDims.x135 = max(NumDims.x133, NumDims.x134);

% Div:
Vars.x137 = Vars.x136 ./ Vars.x135;
NumDims.x137 = max(NumDims.x136, NumDims.x135);

% Abs:
Vars.x138 = abs(Vars.layer_fuzzify_varmfs_theta_far_center_width);
NumDims.x138 = NumDims.layer_fuzzify_varmfs_theta_far_center_width;

% Abs:
Vars.x139 = abs(Vars.layer_fuzzify_varmfs_theta_far_side_width);
NumDims.x139 = NumDims.layer_fuzzify_varmfs_theta_far_side_width;

% Sub:
Vars.x141 = Vars.x130 - Vars.x140;
NumDims.x141 = max(NumDims.x130, NumDims.x140);

% Shape:
[Vars.x142, NumDims.x142] = onnxShape(Vars.x141, NumDims.x141);

% ConstantOfShape:
[Vars.x143, NumDims.x143] = onnxConstantOfShape(Vars.ConstantOfShapeValue1003, Vars.x142);

% Shape:
[Vars.x144, NumDims.x144] = onnxShape(Vars.x141, NumDims.x141);

% ConstantOfShape:
[Vars.x145, NumDims.x145] = onnxConstantOfShape(Vars.ConstantOfShapeValue1004, Vars.x144);

% Abs:
Vars.x146 = abs(Vars.x141);
NumDims.x146 = NumDims.x141;

% Div:
Vars.x149 = Vars.x138 ./ Vars.x450;
NumDims.x149 = max(NumDims.x138, NumDims.x450);

% Greater:
Vars.x150 = Vars.x146 > Vars.x149;
NumDims.x150 = max(NumDims.x146, NumDims.x149);

% Not:
Vars.x151 = not(Vars.x150);
NumDims.x151 = NumDims.x150;

% Add:
Vars.x152 = Vars.x149 + Vars.x137;
NumDims.x152 = max(NumDims.x149, NumDims.x137);

% Greater:
Vars.x153 = Vars.x146 > Vars.x152;
NumDims.x153 = max(NumDims.x146, NumDims.x152);

% Not:
Vars.x154 = not(Vars.x153);
NumDims.x154 = NumDims.x153;

% Not:
Vars.x155 = not(Vars.x151);
NumDims.x155 = NumDims.x151;

% Cast:
Vars.x156 = logical(Vars.x155);
NumDims.x156 = NumDims.x155;

% Cast:
Vars.x157 = logical(Vars.x154);
NumDims.x157 = NumDims.x154;

% And:
Vars.x158 = Vars.x156 & Vars.x157;
NumDims.x158 = max(NumDims.x156, NumDims.x157);

% Cast:
Vars.x159 = logical(Vars.x158);
NumDims.x159 = NumDims.x158;

% Neg:
Vars.x160 = -(Vars.x135);
NumDims.x160 = NumDims.x135;

% Sub:
Vars.x161 = Vars.x146 - Vars.x149;
NumDims.x161 = max(NumDims.x146, NumDims.x149);

% Mul:
Vars.x162 = Vars.x160 .* Vars.x161;
NumDims.x162 = max(NumDims.x160, NumDims.x161);

% Add:
Vars.x164 = Vars.x162 + Vars.x163;
NumDims.x164 = max(NumDims.x162, NumDims.x163);

% Where:
[Vars.x165, NumDims.x165] = onnxWhere(Vars.x159, Vars.x164, Vars.x145, NumDims.x159, NumDims.x164, NumDims.x145);

% Where:
[Vars.x166, NumDims.x166] = onnxWhere(Vars.x151, Vars.x143, Vars.x165, NumDims.x151, NumDims.x143, NumDims.x165);

% Div:
Vars.x169 = Vars.x139 ./ Vars.x451;
NumDims.x169 = max(NumDims.x139, NumDims.x451);

% Add:
Vars.x170 = Vars.x149 + Vars.x169;
NumDims.x170 = max(NumDims.x149, NumDims.x169);

% Add:
Vars.x171 = Vars.x170 + Vars.x137;
NumDims.x171 = max(NumDims.x170, NumDims.x137);

% Mul:
Vars.x172 = Vars.x135 .* Vars.x169;
NumDims.x172 = max(NumDims.x135, NumDims.x169);

% Add:
Vars.x174 = Vars.x172 + Vars.x173;
NumDims.x174 = max(NumDims.x172, NumDims.x173);

% Add:
Vars.x175 = Vars.x141 + Vars.x171;
NumDims.x175 = max(NumDims.x141, NumDims.x171);

% Abs:
Vars.x176 = abs(Vars.x175);
NumDims.x176 = NumDims.x175;

% Greater:
Vars.x177 = Vars.x176 > Vars.x169;
NumDims.x177 = max(NumDims.x176, NumDims.x169);

% Not:
Vars.x178 = not(Vars.x177);
NumDims.x178 = NumDims.x177;

% Add:
Vars.x179 = Vars.x169 + Vars.x137;
NumDims.x179 = max(NumDims.x169, NumDims.x137);

% Greater:
Vars.x180 = Vars.x176 > Vars.x179;
NumDims.x180 = max(NumDims.x176, NumDims.x179);

% Not:
Vars.x181 = not(Vars.x180);
NumDims.x181 = NumDims.x180;

% Not:
Vars.x182 = not(Vars.x178);
NumDims.x182 = NumDims.x178;

% Cast:
Vars.x183 = logical(Vars.x182);
NumDims.x183 = NumDims.x182;

% Cast:
Vars.x184 = logical(Vars.x181);
NumDims.x184 = NumDims.x181;

% And:
Vars.x185 = Vars.x183 & Vars.x184;
NumDims.x185 = max(NumDims.x183, NumDims.x184);

% Cast:
Vars.x186 = logical(Vars.x185);
NumDims.x186 = NumDims.x185;

% Neg:
Vars.x187 = -(Vars.x135);
NumDims.x187 = NumDims.x135;

% Mul:
Vars.x188 = Vars.x187 .* Vars.x176;
NumDims.x188 = max(NumDims.x187, NumDims.x176);

% Add:
Vars.x189 = Vars.x188 + Vars.x174;
NumDims.x189 = max(NumDims.x188, NumDims.x174);

% Where:
[Vars.x190, NumDims.x190] = onnxWhere(Vars.x186, Vars.x189, Vars.x145, NumDims.x186, NumDims.x189, NumDims.x145);

% Where:
[Vars.x191, NumDims.x191] = onnxWhere(Vars.x178, Vars.x143, Vars.x190, NumDims.x178, NumDims.x143, NumDims.x190);

% Sub:
Vars.x192 = Vars.x141 - Vars.x171;
NumDims.x192 = max(NumDims.x141, NumDims.x171);

% Abs:
Vars.x193 = abs(Vars.x192);
NumDims.x193 = NumDims.x192;

% Greater:
Vars.x194 = Vars.x193 > Vars.x169;
NumDims.x194 = max(NumDims.x193, NumDims.x169);

% Not:
Vars.x195 = not(Vars.x194);
NumDims.x195 = NumDims.x194;

% Add:
Vars.x196 = Vars.x169 + Vars.x137;
NumDims.x196 = max(NumDims.x169, NumDims.x137);

% Greater:
Vars.x197 = Vars.x193 > Vars.x196;
NumDims.x197 = max(NumDims.x193, NumDims.x196);

% Not:
Vars.x198 = not(Vars.x197);
NumDims.x198 = NumDims.x197;

% Not:
Vars.x199 = not(Vars.x195);
NumDims.x199 = NumDims.x195;

% Cast:
Vars.x200 = logical(Vars.x199);
NumDims.x200 = NumDims.x199;

% Cast:
Vars.x201 = logical(Vars.x198);
NumDims.x201 = NumDims.x198;

% And:
Vars.x202 = Vars.x200 & Vars.x201;
NumDims.x202 = max(NumDims.x200, NumDims.x201);

% Cast:
Vars.x203 = logical(Vars.x202);
NumDims.x203 = NumDims.x202;

% Neg:
Vars.x204 = -(Vars.x135);
NumDims.x204 = NumDims.x135;

% Mul:
Vars.x205 = Vars.x204 .* Vars.x193;
NumDims.x205 = max(NumDims.x204, NumDims.x193);

% Add:
Vars.x206 = Vars.x205 + Vars.x174;
NumDims.x206 = max(NumDims.x205, NumDims.x174);

% Where:
[Vars.x207, NumDims.x207] = onnxWhere(Vars.x203, Vars.x206, Vars.x145, NumDims.x203, NumDims.x206, NumDims.x145);

% Where:
[Vars.x208, NumDims.x208] = onnxWhere(Vars.x195, Vars.x143, Vars.x207, NumDims.x195, NumDims.x143, NumDims.x207);

% Add:
Vars.x209 = Vars.x149 + Vars.x139;
NumDims.x209 = max(NumDims.x149, NumDims.x139);

% Mul:
Vars.x211 = Vars.x137 .* Vars.x210;
NumDims.x211 = max(NumDims.x137, NumDims.x210);

% Add:
Vars.x212 = Vars.x209 + Vars.x211;
NumDims.x212 = max(NumDims.x209, NumDims.x211);

% Mul:
Vars.x213 = Vars.x135 .* Vars.x137;
NumDims.x213 = max(NumDims.x135, NumDims.x137);

% Neg:
Vars.x214 = -(Vars.x141);
NumDims.x214 = NumDims.x141;

% Sub:
Vars.x215 = Vars.x214 - Vars.x212;
NumDims.x215 = max(NumDims.x214, NumDims.x212);

% Greater:
Vars.x217 = Vars.x215 > Vars.x216;
NumDims.x217 = max(NumDims.x215, NumDims.x216);

% Neg:
Vars.x218 = -(Vars.x137);
NumDims.x218 = NumDims.x137;

% Less:
Vars.x219 = Vars.x215 < Vars.x218;
NumDims.x219 = max(NumDims.x215, NumDims.x218);

% Not:
Vars.x220 = not(Vars.x219);
NumDims.x220 = NumDims.x219;

% Not:
Vars.x221 = not(Vars.x217);
NumDims.x221 = NumDims.x217;

% Cast:
Vars.x222 = logical(Vars.x221);
NumDims.x222 = NumDims.x221;

% Cast:
Vars.x223 = logical(Vars.x220);
NumDims.x223 = NumDims.x220;

% And:
Vars.x224 = Vars.x222 & Vars.x223;
NumDims.x224 = max(NumDims.x222, NumDims.x223);

% Cast:
Vars.x225 = logical(Vars.x224);
NumDims.x225 = NumDims.x224;

% Mul:
Vars.x226 = Vars.x135 .* Vars.x215;
NumDims.x226 = max(NumDims.x135, NumDims.x215);

% Add:
Vars.x227 = Vars.x226 + Vars.x213;
NumDims.x227 = max(NumDims.x226, NumDims.x213);

% Where:
[Vars.x228, NumDims.x228] = onnxWhere(Vars.x225, Vars.x227, Vars.x145, NumDims.x225, NumDims.x227, NumDims.x145);

% Where:
[Vars.x229, NumDims.x229] = onnxWhere(Vars.x217, Vars.x143, Vars.x228, NumDims.x217, NumDims.x143, NumDims.x228);

% Sub:
Vars.x230 = Vars.x141 - Vars.x212;
NumDims.x230 = max(NumDims.x141, NumDims.x212);

% Greater:
Vars.x232 = Vars.x230 > Vars.x231;
NumDims.x232 = max(NumDims.x230, NumDims.x231);

% Neg:
Vars.x233 = -(Vars.x137);
NumDims.x233 = NumDims.x137;

% Less:
Vars.x234 = Vars.x230 < Vars.x233;
NumDims.x234 = max(NumDims.x230, NumDims.x233);

% Not:
Vars.x235 = not(Vars.x234);
NumDims.x235 = NumDims.x234;

% Not:
Vars.x236 = not(Vars.x232);
NumDims.x236 = NumDims.x232;

% Cast:
Vars.x237 = logical(Vars.x236);
NumDims.x237 = NumDims.x236;

% Cast:
Vars.x238 = logical(Vars.x235);
NumDims.x238 = NumDims.x235;

% And:
Vars.x239 = Vars.x237 & Vars.x238;
NumDims.x239 = max(NumDims.x237, NumDims.x238);

% Cast:
Vars.x240 = logical(Vars.x239);
NumDims.x240 = NumDims.x239;

% Mul:
Vars.x241 = Vars.x135 .* Vars.x230;
NumDims.x241 = max(NumDims.x135, NumDims.x230);

% Add:
Vars.x242 = Vars.x241 + Vars.x213;
NumDims.x242 = max(NumDims.x241, NumDims.x213);

% Where:
[Vars.x243, NumDims.x243] = onnxWhere(Vars.x240, Vars.x242, Vars.x145, NumDims.x240, NumDims.x242, NumDims.x145);

% Where:
[Vars.x244, NumDims.x244] = onnxWhere(Vars.x232, Vars.x143, Vars.x243, NumDims.x232, NumDims.x143, NumDims.x243);

% Concat:
[dim, NumDims.x245] = prepareConcatArgs(1, [NumDims.x229, NumDims.x191, NumDims.x166, NumDims.x208, NumDims.x244]);
Vars.x245 = cat(dim, Vars.x229, Vars.x191, Vars.x166, Vars.x208, Vars.x244);

% Slice:
[Indices, NumDims.x246] = prepareSliceArgs(Vars.input, [2], [3], [1], [], NumDims.input);
Vars.x246 = subsref(Vars.input, Indices);

% Abs:
Vars.x249 = abs(Vars.x452);
NumDims.x249 = NumDims.x452;

% Add:
Vars.x251 = Vars.x249 + Vars.x250;
NumDims.x251 = max(NumDims.x249, NumDims.x250);

% Div:
Vars.x253 = Vars.x252 ./ Vars.x251;
NumDims.x253 = max(NumDims.x252, NumDims.x251);

% Abs:
Vars.x254 = abs(Vars.layer_fuzzify_varmfs_theta_near_center_width);
NumDims.x254 = NumDims.layer_fuzzify_varmfs_theta_near_center_width;

% Abs:
Vars.x255 = abs(Vars.layer_fuzzify_varmfs_theta_near_side_width);
NumDims.x255 = NumDims.layer_fuzzify_varmfs_theta_near_side_width;

% Sub:
Vars.x257 = Vars.x246 - Vars.x256;
NumDims.x257 = max(NumDims.x246, NumDims.x256);

% Shape:
[Vars.x258, NumDims.x258] = onnxShape(Vars.x257, NumDims.x257);

% ConstantOfShape:
[Vars.x259, NumDims.x259] = onnxConstantOfShape(Vars.ConstantOfShapeValue1005, Vars.x258);

% Shape:
[Vars.x260, NumDims.x260] = onnxShape(Vars.x257, NumDims.x257);

% ConstantOfShape:
[Vars.x261, NumDims.x261] = onnxConstantOfShape(Vars.ConstantOfShapeValue1006, Vars.x260);

% Abs:
Vars.x262 = abs(Vars.x257);
NumDims.x262 = NumDims.x257;

% Div:
Vars.x265 = Vars.x254 ./ Vars.x453;
NumDims.x265 = max(NumDims.x254, NumDims.x453);

% Greater:
Vars.x266 = Vars.x262 > Vars.x265;
NumDims.x266 = max(NumDims.x262, NumDims.x265);

% Not:
Vars.x267 = not(Vars.x266);
NumDims.x267 = NumDims.x266;

% Add:
Vars.x268 = Vars.x265 + Vars.x253;
NumDims.x268 = max(NumDims.x265, NumDims.x253);

% Greater:
Vars.x269 = Vars.x262 > Vars.x268;
NumDims.x269 = max(NumDims.x262, NumDims.x268);

% Not:
Vars.x270 = not(Vars.x269);
NumDims.x270 = NumDims.x269;

% Not:
Vars.x271 = not(Vars.x267);
NumDims.x271 = NumDims.x267;

% Cast:
Vars.x272 = logical(Vars.x271);
NumDims.x272 = NumDims.x271;

% Cast:
Vars.x273 = logical(Vars.x270);
NumDims.x273 = NumDims.x270;

% And:
Vars.x274 = Vars.x272 & Vars.x273;
NumDims.x274 = max(NumDims.x272, NumDims.x273);

% Cast:
Vars.x275 = logical(Vars.x274);
NumDims.x275 = NumDims.x274;

% Neg:
Vars.x276 = -(Vars.x251);
NumDims.x276 = NumDims.x251;

% Sub:
Vars.x277 = Vars.x262 - Vars.x265;
NumDims.x277 = max(NumDims.x262, NumDims.x265);

% Mul:
Vars.x278 = Vars.x276 .* Vars.x277;
NumDims.x278 = max(NumDims.x276, NumDims.x277);

% Add:
Vars.x280 = Vars.x278 + Vars.x279;
NumDims.x280 = max(NumDims.x278, NumDims.x279);

% Where:
[Vars.x281, NumDims.x281] = onnxWhere(Vars.x275, Vars.x280, Vars.x261, NumDims.x275, NumDims.x280, NumDims.x261);

% Where:
[Vars.x282, NumDims.x282] = onnxWhere(Vars.x267, Vars.x259, Vars.x281, NumDims.x267, NumDims.x259, NumDims.x281);

% Div:
Vars.x285 = Vars.x255 ./ Vars.x454;
NumDims.x285 = max(NumDims.x255, NumDims.x454);

% Add:
Vars.x286 = Vars.x265 + Vars.x285;
NumDims.x286 = max(NumDims.x265, NumDims.x285);

% Add:
Vars.x287 = Vars.x286 + Vars.x253;
NumDims.x287 = max(NumDims.x286, NumDims.x253);

% Mul:
Vars.x288 = Vars.x251 .* Vars.x285;
NumDims.x288 = max(NumDims.x251, NumDims.x285);

% Add:
Vars.x290 = Vars.x288 + Vars.x289;
NumDims.x290 = max(NumDims.x288, NumDims.x289);

% Add:
Vars.x291 = Vars.x257 + Vars.x287;
NumDims.x291 = max(NumDims.x257, NumDims.x287);

% Abs:
Vars.x292 = abs(Vars.x291);
NumDims.x292 = NumDims.x291;

% Greater:
Vars.x293 = Vars.x292 > Vars.x285;
NumDims.x293 = max(NumDims.x292, NumDims.x285);

% Not:
Vars.x294 = not(Vars.x293);
NumDims.x294 = NumDims.x293;

% Add:
Vars.x295 = Vars.x285 + Vars.x253;
NumDims.x295 = max(NumDims.x285, NumDims.x253);

% Greater:
Vars.x296 = Vars.x292 > Vars.x295;
NumDims.x296 = max(NumDims.x292, NumDims.x295);

% Not:
Vars.x297 = not(Vars.x296);
NumDims.x297 = NumDims.x296;

% Not:
Vars.x298 = not(Vars.x294);
NumDims.x298 = NumDims.x294;

% Cast:
Vars.x299 = logical(Vars.x298);
NumDims.x299 = NumDims.x298;

% Cast:
Vars.x300 = logical(Vars.x297);
NumDims.x300 = NumDims.x297;

% And:
Vars.x301 = Vars.x299 & Vars.x300;
NumDims.x301 = max(NumDims.x299, NumDims.x300);

% Cast:
Vars.x302 = logical(Vars.x301);
NumDims.x302 = NumDims.x301;

% Neg:
Vars.x303 = -(Vars.x251);
NumDims.x303 = NumDims.x251;

% Mul:
Vars.x304 = Vars.x303 .* Vars.x292;
NumDims.x304 = max(NumDims.x303, NumDims.x292);

% Add:
Vars.x305 = Vars.x304 + Vars.x290;
NumDims.x305 = max(NumDims.x304, NumDims.x290);

% Where:
[Vars.x306, NumDims.x306] = onnxWhere(Vars.x302, Vars.x305, Vars.x261, NumDims.x302, NumDims.x305, NumDims.x261);

% Where:
[Vars.x307, NumDims.x307] = onnxWhere(Vars.x294, Vars.x259, Vars.x306, NumDims.x294, NumDims.x259, NumDims.x306);

% Sub:
Vars.x308 = Vars.x257 - Vars.x287;
NumDims.x308 = max(NumDims.x257, NumDims.x287);

% Abs:
Vars.x309 = abs(Vars.x308);
NumDims.x309 = NumDims.x308;

% Greater:
Vars.x310 = Vars.x309 > Vars.x285;
NumDims.x310 = max(NumDims.x309, NumDims.x285);

% Not:
Vars.x311 = not(Vars.x310);
NumDims.x311 = NumDims.x310;

% Add:
Vars.x312 = Vars.x285 + Vars.x253;
NumDims.x312 = max(NumDims.x285, NumDims.x253);

% Greater:
Vars.x313 = Vars.x309 > Vars.x312;
NumDims.x313 = max(NumDims.x309, NumDims.x312);

% Not:
Vars.x314 = not(Vars.x313);
NumDims.x314 = NumDims.x313;

% Not:
Vars.x315 = not(Vars.x311);
NumDims.x315 = NumDims.x311;

% Cast:
Vars.x316 = logical(Vars.x315);
NumDims.x316 = NumDims.x315;

% Cast:
Vars.x317 = logical(Vars.x314);
NumDims.x317 = NumDims.x314;

% And:
Vars.x318 = Vars.x316 & Vars.x317;
NumDims.x318 = max(NumDims.x316, NumDims.x317);

% Cast:
Vars.x319 = logical(Vars.x318);
NumDims.x319 = NumDims.x318;

% Neg:
Vars.x320 = -(Vars.x251);
NumDims.x320 = NumDims.x251;

% Mul:
Vars.x321 = Vars.x320 .* Vars.x309;
NumDims.x321 = max(NumDims.x320, NumDims.x309);

% Add:
Vars.x322 = Vars.x321 + Vars.x290;
NumDims.x322 = max(NumDims.x321, NumDims.x290);

% Where:
[Vars.x323, NumDims.x323] = onnxWhere(Vars.x319, Vars.x322, Vars.x261, NumDims.x319, NumDims.x322, NumDims.x261);

% Where:
[Vars.x324, NumDims.x324] = onnxWhere(Vars.x311, Vars.x259, Vars.x323, NumDims.x311, NumDims.x259, NumDims.x323);

% Add:
Vars.x325 = Vars.x265 + Vars.x255;
NumDims.x325 = max(NumDims.x265, NumDims.x255);

% Mul:
Vars.x327 = Vars.x253 .* Vars.x326;
NumDims.x327 = max(NumDims.x253, NumDims.x326);

% Add:
Vars.x328 = Vars.x325 + Vars.x327;
NumDims.x328 = max(NumDims.x325, NumDims.x327);

% Mul:
Vars.x329 = Vars.x251 .* Vars.x253;
NumDims.x329 = max(NumDims.x251, NumDims.x253);

% Neg:
Vars.x330 = -(Vars.x257);
NumDims.x330 = NumDims.x257;

% Sub:
Vars.x331 = Vars.x330 - Vars.x328;
NumDims.x331 = max(NumDims.x330, NumDims.x328);

% Greater:
Vars.x333 = Vars.x331 > Vars.x332;
NumDims.x333 = max(NumDims.x331, NumDims.x332);

% Neg:
Vars.x334 = -(Vars.x253);
NumDims.x334 = NumDims.x253;

% Less:
Vars.x335 = Vars.x331 < Vars.x334;
NumDims.x335 = max(NumDims.x331, NumDims.x334);

% Not:
Vars.x336 = not(Vars.x335);
NumDims.x336 = NumDims.x335;

% Not:
Vars.x337 = not(Vars.x333);
NumDims.x337 = NumDims.x333;

% Cast:
Vars.x338 = logical(Vars.x337);
NumDims.x338 = NumDims.x337;

% Cast:
Vars.x339 = logical(Vars.x336);
NumDims.x339 = NumDims.x336;

% And:
Vars.x340 = Vars.x338 & Vars.x339;
NumDims.x340 = max(NumDims.x338, NumDims.x339);

% Cast:
Vars.x341 = logical(Vars.x340);
NumDims.x341 = NumDims.x340;

% Mul:
Vars.x342 = Vars.x251 .* Vars.x331;
NumDims.x342 = max(NumDims.x251, NumDims.x331);

% Add:
Vars.x343 = Vars.x342 + Vars.x329;
NumDims.x343 = max(NumDims.x342, NumDims.x329);

% Where:
[Vars.x344, NumDims.x344] = onnxWhere(Vars.x341, Vars.x343, Vars.x261, NumDims.x341, NumDims.x343, NumDims.x261);

% Where:
[Vars.x345, NumDims.x345] = onnxWhere(Vars.x333, Vars.x259, Vars.x344, NumDims.x333, NumDims.x259, NumDims.x344);

% Sub:
Vars.x346 = Vars.x257 - Vars.x328;
NumDims.x346 = max(NumDims.x257, NumDims.x328);

% Greater:
Vars.x348 = Vars.x346 > Vars.x347;
NumDims.x348 = max(NumDims.x346, NumDims.x347);

% Neg:
Vars.x349 = -(Vars.x253);
NumDims.x349 = NumDims.x253;

% Less:
Vars.x350 = Vars.x346 < Vars.x349;
NumDims.x350 = max(NumDims.x346, NumDims.x349);

% Not:
Vars.x351 = not(Vars.x350);
NumDims.x351 = NumDims.x350;

% Not:
Vars.x352 = not(Vars.x348);
NumDims.x352 = NumDims.x348;

% Cast:
Vars.x353 = logical(Vars.x352);
NumDims.x353 = NumDims.x352;

% Cast:
Vars.x354 = logical(Vars.x351);
NumDims.x354 = NumDims.x351;

% And:
Vars.x355 = Vars.x353 & Vars.x354;
NumDims.x355 = max(NumDims.x353, NumDims.x354);

% Cast:
Vars.x356 = logical(Vars.x355);
NumDims.x356 = NumDims.x355;

% Mul:
Vars.x357 = Vars.x251 .* Vars.x346;
NumDims.x357 = max(NumDims.x251, NumDims.x346);

% Add:
Vars.x358 = Vars.x357 + Vars.x329;
NumDims.x358 = max(NumDims.x357, NumDims.x329);

% Where:
[Vars.x359, NumDims.x359] = onnxWhere(Vars.x356, Vars.x358, Vars.x261, NumDims.x356, NumDims.x358, NumDims.x261);

% Where:
[Vars.x360, NumDims.x360] = onnxWhere(Vars.x348, Vars.x259, Vars.x359, NumDims.x348, NumDims.x259, NumDims.x359);

% Concat:
[dim, NumDims.x361] = prepareConcatArgs(1, [NumDims.x345, NumDims.x307, NumDims.x282, NumDims.x324, NumDims.x360]);
Vars.x361 = cat(dim, Vars.x345, Vars.x307, Vars.x282, Vars.x324, Vars.x360);

% Unsqueeze:
[shape, NumDims.x362] = prepareUnsqueezeArgs(Vars.x129, Vars.UnsqueezeAxes1007, NumDims.x129);
Vars.x362 = reshape(Vars.x129, shape);

% Unsqueeze:
[shape, NumDims.x363] = prepareUnsqueezeArgs(Vars.x245, Vars.UnsqueezeAxes1008, NumDims.x245);
Vars.x363 = reshape(Vars.x245, shape);

% Unsqueeze:
[shape, NumDims.x364] = prepareUnsqueezeArgs(Vars.x361, Vars.UnsqueezeAxes1009, NumDims.x361);
Vars.x364 = reshape(Vars.x361, shape);

% Concat:
[dim, NumDims.x365] = prepareConcatArgs(1, [NumDims.x362, NumDims.x363, NumDims.x364]);
Vars.x365 = cat(dim, Vars.x362, Vars.x363, Vars.x364);

% Shape:
[Vars.x366, NumDims.x366] = onnxShape(Vars.x365, NumDims.x365);

% Gather:
[Vars.x368, NumDims.x368] = onnxGather(Vars.x366, Vars.x367, 0, NumDims.x366, NumDims.x367);

% Gather:
[Vars.x370, NumDims.x370] = onnxGather(Vars.x366, Vars.x369, 0, NumDims.x366, NumDims.x369);

% Transpose:
[perm, NumDims.x371] = prepareTransposeArgs(Vars.TransposePerm1010, NumDims.x365);
if ~isempty(perm)
    Vars.x371 = permute(Vars.x365, perm);
end

% Flatten:
[dim1, dim2, NumDims.x372] = prepareFlattenArgs(Vars.x371, 2, NumDims.x371);
Vars.x372 = reshape(Vars.x371, dim1, dim2);

% Mul:
Vars.x374 = Vars.x373 .* Vars.x370;
NumDims.x374 = max(NumDims.x373, NumDims.x370);

% Add:
Vars.x376 = Vars.x375 + Vars.x374;
NumDims.x376 = max(NumDims.x375, NumDims.x374);

% Gather:
[Vars.x377, NumDims.x377] = onnxGather(Vars.x372, Vars.x376, 0, NumDims.x372, NumDims.x376);

% Shape:
[Vars.x378, NumDims.x378] = onnxShape(Vars.x376, NumDims.x376);

% Concat:
[dim, NumDims.x380] = prepareConcatArgs(0, [NumDims.x379, NumDims.x368]);
Vars.x380 = cat(dim, Vars.x379, Vars.x368);

% Reshape:
[shape, NumDims.x381] = prepareReshapeArgs(Vars.x377, Vars.x380, NumDims.x377);
Vars.x381 = reshape(Vars.x377, shape{:});

% Transpose:
[perm, NumDims.x382] = prepareTransposeArgs(Vars.TransposePerm1011, NumDims.x381);
if ~isempty(perm)
    Vars.x382 = permute(Vars.x381, perm);
end

% Concat:
[dim, NumDims.x383] = prepareConcatArgs(0, [NumDims.x368, NumDims.x378]);
Vars.x383 = cat(dim, Vars.x368, Vars.x378);

% Reshape:
[shape, NumDims.x384] = prepareReshapeArgs(Vars.x382, Vars.x383, NumDims.x382);
Vars.x384 = reshape(Vars.x382, shape{:});

% ReduceMin:
dims = prepareReduceArgs(Vars.ReduceMinAxes1012, NumDims.x384);
Vars.x385 = min(Vars.x384, [], dims);
[Vars.x385, NumDims.x385] = onnxSqueeze(Vars.x385, Vars.ReduceMinAxes1012, NumDims.x384);

% PLACEHOLDER FUNCTION FOR UNSUPPORTED OPERATOR (ReduceL1):
[Vars.x386, NumDims.x386] = max(sum(abs(Vars.x385)));

% Clip:
Vars.x387 = min(Vars.Clipmax1014, max(Vars.Clipmin1013, Vars.x386));
NumDims.x387 = NumDims.x386;

% Shape:
[Vars.x388, NumDims.x388] = onnxShape(Vars.x385, NumDims.x385);

% Expand:
[shape, NumDims.x389] = prepareExpandArgs(Vars.x388);
Vars.x389 = Vars.x387 + zeros(shape);

% Div:
Vars.x390 = Vars.x385 ./ Vars.x389;
NumDims.x390 = max(NumDims.x385, NumDims.x389);

% Abs:
Vars.x391 = abs(Vars.layer_consequent_mamdani_defs_soft);
NumDims.x391 = NumDims.layer_consequent_mamdani_defs_soft;

% Abs:
Vars.x392 = abs(Vars.layer_consequent_mamdani_defs_normal);
NumDims.x392 = NumDims.layer_consequent_mamdani_defs_normal;

% Abs:
Vars.x393 = abs(Vars.layer_consequent_mamdani_defs_hard);
NumDims.x393 = NumDims.layer_consequent_mamdani_defs_hard;

% Add:
Vars.x394 = Vars.x391 + Vars.x392;
NumDims.x394 = max(NumDims.x391, NumDims.x392);

% Add:
Vars.x395 = Vars.x394 + Vars.x393;
NumDims.x395 = max(NumDims.x394, NumDims.x393);

% Mul:
Vars.x397 = Vars.x395 .* Vars.x396;
NumDims.x397 = max(NumDims.x395, NumDims.x396);

% Add:
Vars.x398 = Vars.layer_consequent_mamdani_defs_center + Vars.x397;
NumDims.x398 = max(NumDims.layer_consequent_mamdani_defs_center, NumDims.x397);

% Add:
Vars.x399 = Vars.x391 + Vars.x392;
NumDims.x399 = max(NumDims.x391, NumDims.x392);

% Mul:
Vars.x401 = Vars.x399 .* Vars.x400;
NumDims.x401 = max(NumDims.x399, NumDims.x400);

% Add:
Vars.x402 = Vars.layer_consequent_mamdani_defs_center + Vars.x401;
NumDims.x402 = max(NumDims.layer_consequent_mamdani_defs_center, NumDims.x401);

% Mul:
Vars.x404 = Vars.x391 .* Vars.x403;
NumDims.x404 = max(NumDims.x391, NumDims.x403);

% Add:
Vars.x405 = Vars.layer_consequent_mamdani_defs_center + Vars.x404;
NumDims.x405 = max(NumDims.layer_consequent_mamdani_defs_center, NumDims.x404);

% Mul:
Vars.x407 = Vars.x391 .* Vars.x406;
NumDims.x407 = max(NumDims.x391, NumDims.x406);

% Add:
Vars.x408 = Vars.layer_consequent_mamdani_defs_center + Vars.x407;
NumDims.x408 = max(NumDims.layer_consequent_mamdani_defs_center, NumDims.x407);

% Add:
Vars.x409 = Vars.x391 + Vars.x392;
NumDims.x409 = max(NumDims.x391, NumDims.x392);

% Mul:
Vars.x411 = Vars.x409 .* Vars.x410;
NumDims.x411 = max(NumDims.x409, NumDims.x410);

% Add:
Vars.x412 = Vars.layer_consequent_mamdani_defs_center + Vars.x411;
NumDims.x412 = max(NumDims.layer_consequent_mamdani_defs_center, NumDims.x411);

% Add:
Vars.x413 = Vars.x391 + Vars.x392;
NumDims.x413 = max(NumDims.x391, NumDims.x392);

% Add:
Vars.x414 = Vars.x413 + Vars.x393;
NumDims.x414 = max(NumDims.x413, NumDims.x393);

% Mul:
Vars.x416 = Vars.x414 .* Vars.x415;
NumDims.x416 = max(NumDims.x414, NumDims.x415);

% Add:
Vars.x417 = Vars.layer_consequent_mamdani_defs_center + Vars.x416;
NumDims.x417 = max(NumDims.layer_consequent_mamdani_defs_center, NumDims.x416);

% Unsqueeze:
[shape, NumDims.x418] = prepareUnsqueezeArgs(Vars.x417, Vars.UnsqueezeAxes1015, NumDims.x417);
Vars.x418 = reshape(Vars.x417, shape);

% Unsqueeze:
[shape, NumDims.x419] = prepareUnsqueezeArgs(Vars.x412, Vars.UnsqueezeAxes1016, NumDims.x412);
Vars.x419 = reshape(Vars.x412, shape);

% Unsqueeze:
[shape, NumDims.x421] = prepareUnsqueezeArgs(Vars.x402, Vars.UnsqueezeAxes1017, NumDims.x402);
Vars.x421 = reshape(Vars.x402, shape);

% Unsqueeze:
[shape, NumDims.x422] = prepareUnsqueezeArgs(Vars.x398, Vars.UnsqueezeAxes1018, NumDims.x398);
Vars.x422 = reshape(Vars.x398, shape);

% Unsqueeze:
[shape, NumDims.x423] = prepareUnsqueezeArgs(Vars.x398, Vars.UnsqueezeAxes1019, NumDims.x398);
Vars.x423 = reshape(Vars.x398, shape);

% Unsqueeze:
[shape, NumDims.x424] = prepareUnsqueezeArgs(Vars.x402, Vars.UnsqueezeAxes1020, NumDims.x402);
Vars.x424 = reshape(Vars.x402, shape);

% Unsqueeze:
[shape, NumDims.x426] = prepareUnsqueezeArgs(Vars.x412, Vars.UnsqueezeAxes1021, NumDims.x412);
Vars.x426 = reshape(Vars.x412, shape);

% Unsqueeze:
[shape, NumDims.x427] = prepareUnsqueezeArgs(Vars.x417, Vars.UnsqueezeAxes1022, NumDims.x417);
Vars.x427 = reshape(Vars.x417, shape);

% Unsqueeze:
[shape, NumDims.x428] = prepareUnsqueezeArgs(Vars.x417, Vars.UnsqueezeAxes1023, NumDims.x417);
Vars.x428 = reshape(Vars.x417, shape);

% Unsqueeze:
[shape, NumDims.x429] = prepareUnsqueezeArgs(Vars.x412, Vars.UnsqueezeAxes1024, NumDims.x412);
Vars.x429 = reshape(Vars.x412, shape);

% Unsqueeze:
[shape, NumDims.x430] = prepareUnsqueezeArgs(Vars.x408, Vars.UnsqueezeAxes1025, NumDims.x408);
Vars.x430 = reshape(Vars.x408, shape);

% Unsqueeze:
[shape, NumDims.x432] = prepareUnsqueezeArgs(Vars.x405, Vars.UnsqueezeAxes1026, NumDims.x405);
Vars.x432 = reshape(Vars.x405, shape);

% Unsqueeze:
[shape, NumDims.x433] = prepareUnsqueezeArgs(Vars.x412, Vars.UnsqueezeAxes1027, NumDims.x412);
Vars.x433 = reshape(Vars.x412, shape);

% Unsqueeze:
[shape, NumDims.x434] = prepareUnsqueezeArgs(Vars.x408, Vars.UnsqueezeAxes1028, NumDims.x408);
Vars.x434 = reshape(Vars.x408, shape);

% Unsqueeze:
[shape, NumDims.x436] = prepareUnsqueezeArgs(Vars.x405, Vars.UnsqueezeAxes1029, NumDims.x405);
Vars.x436 = reshape(Vars.x405, shape);

% Unsqueeze:
[shape, NumDims.x437] = prepareUnsqueezeArgs(Vars.x402, Vars.UnsqueezeAxes1030, NumDims.x402);
Vars.x437 = reshape(Vars.x402, shape);

% Unsqueeze:
[shape, NumDims.x438] = prepareUnsqueezeArgs(Vars.x408, Vars.UnsqueezeAxes1031, NumDims.x408);
Vars.x438 = reshape(Vars.x408, shape);

% Unsqueeze:
[shape, NumDims.x440] = prepareUnsqueezeArgs(Vars.x405, Vars.UnsqueezeAxes1032, NumDims.x405);
Vars.x440 = reshape(Vars.x405, shape);

% Unsqueeze:
[shape, NumDims.x441] = prepareUnsqueezeArgs(Vars.x402, Vars.UnsqueezeAxes1033, NumDims.x402);
Vars.x441 = reshape(Vars.x402, shape);

% Unsqueeze:
[shape, NumDims.x442] = prepareUnsqueezeArgs(Vars.x398, Vars.UnsqueezeAxes1034, NumDims.x398);
Vars.x442 = reshape(Vars.x398, shape);

% Concat:
[dim, NumDims.x443] = prepareConcatArgs(0, [NumDims.x418, NumDims.x419, NumDims.x455, NumDims.x421, NumDims.x422, NumDims.x423, NumDims.x424, NumDims.x456, NumDims.x426, NumDims.x427, NumDims.x428, NumDims.x429, NumDims.x430, NumDims.x457, NumDims.x432, NumDims.x433, NumDims.x434, NumDims.x458, NumDims.x436, NumDims.x437, NumDims.x438, NumDims.x459, NumDims.x440, NumDims.x441, NumDims.x442]);
Vars.x443 = cat(dim, Vars.x418, Vars.x419, Vars.x455, Vars.x421, Vars.x422, Vars.x423, Vars.x424, Vars.x456, Vars.x426, Vars.x427, Vars.x428, Vars.x429, Vars.x430, Vars.x457, Vars.x432, Vars.x433, Vars.x434, Vars.x458, Vars.x436, Vars.x437, Vars.x438, Vars.x459, Vars.x440, Vars.x441, Vars.x442);

% Unsqueeze:
[shape, NumDims.x444] = prepareUnsqueezeArgs(Vars.x443, Vars.UnsqueezeAxes1035, NumDims.x443);
Vars.x444 = reshape(Vars.x443, shape);

% MatMul:
[Vars.output, NumDims.output] = onnxMatMul(Vars.x390, Vars.x444, NumDims.x390, NumDims.x444);

% Set graph output arguments from Vars and NumDims:
output = Vars.output;
outputNumDims1037 = NumDims.output;
% Set output state from Vars:
state = updateStruct(state, Vars);
end

function [inputDataPerms, outputDataPerms, Training] = parseInputs(input, numDataOutputs, params, varargin)
% Function to validate inputs to ANFISFcn:
p = inputParser;
isValidArrayInput = @(x)isnumeric(x) || isstring(x);
isValidONNXParameters = @(x)isa(x, 'ONNXParameters');
addRequired(p, 'input', isValidArrayInput);
addRequired(p, 'params', isValidONNXParameters);
addParameter(p, 'InputDataPermutation', 'auto');
addParameter(p, 'OutputDataPermutation', 'auto');
addParameter(p, 'Training', false);
parse(p, input, params, varargin{:});
inputDataPerms = p.Results.InputDataPermutation;
outputDataPerms = p.Results.OutputDataPermutation;
Training = p.Results.Training;
if isnumeric(inputDataPerms)
    inputDataPerms = {inputDataPerms};
end
if isstring(inputDataPerms) && isscalar(inputDataPerms) || ischar(inputDataPerms)
    inputDataPerms = repmat({inputDataPerms},1,1);
end
if isnumeric(outputDataPerms)
    outputDataPerms = {outputDataPerms};
end
if isstring(outputDataPerms) && isscalar(outputDataPerms) || ischar(outputDataPerms)
    outputDataPerms = repmat({outputDataPerms},1,numDataOutputs);
end
end

function [input, Training, outputDataPerms, anyDlarrayInputs] = preprocessInput(input, params, varargin)
% Parse input arguments
[inputDataPerms, outputDataPerms, Training] = parseInputs(input, 1, params, varargin{:});
anyDlarrayInputs = any(cellfun(@(x)isa(x, 'dlarray'), {input}));
% Make the input variables into unlabelled dlarrays:
input = makeUnlabeledDlarray(input);
% Permute inputs if requested:
input = permuteInputVar(input, inputDataPerms{1}, 2);
% Check input size(s):
checkInputSize(size(input), {'batch_size' 3}, "input");
end

function [output] = postprocessOutput(output, outputDataPerms, anyDlarrayInputs, Training, varargin)
% Set output type:
if ~anyDlarrayInputs && ~Training
    output = extractdata(output);
end
% Permute outputs if requested:
output = permuteOutputVar(output, outputDataPerms{1}, 2);
end


%% dlarray functions implementing ONNX operators:

function [Y, numDimsY] = onnxConstantOfShape(value, ONNXShape)
% Returns a DLT tensor with the reverse of the ONNXShape.
DLTShape = fliplr(extractdata(ONNXShape(:)'));
numDimsY = numel(DLTShape);
switch numDimsY
    case 0
        % If shape is empty, output is a scalar
        Y = value;
    case 1
        Y = ones(DLTShape,1) .* value;
    otherwise
        Y = ones(DLTShape) .* value;
end
end

function [Y, numDimsY] = onnxGather(X, ONNXIdx, ONNXAxis, numDimsX, numDimsIdx)
% Function implementing the ONNX Gather operator

% In ONNX, 'Gather' first indexes into dimension ONNXAxis of data, using
% the contents of ONNXIdx as the indices. Then, it reshapes the ONNXAxis
% into the shape of ONNXIdx.
%   Example 1:
% Suppose data has shape [2 3 4 5], ONNXIdx has shape [6 7], and axis=1.
% The result has shape [2 6 7 4 5].
%   Example 2:
% Suppose data has shape [2 3 4 5], ONNXIdx has shape [6], and axis=1.
% The result has shape [2 6 4 5].
%   Example 3:
% Suppose data has shape [2 3 4 5], ONNXIdx has shape [] (a scalar), and axis=1.
% The result has shape [2 4 5].
%
% Since we're using reverse indexing relative to ONNX, in this function
% data and ONNXIdx both have reversed dimension ordering.
numDimsY = numDimsIdx + (numDimsX - 1);
if isempty(X)
    Y = X;
    return;
end
% (1) First, do the subsref part of Gather
if ONNXAxis<0
    ONNXAxis = ONNXAxis + numDimsX;                                 % Axis can be negative. Convert it to its positive equivalent.
end
% ONNXIdx is origin-0 in ONNX, so add 1
mlIdx  = extractdata(ONNXIdx) + 1;
% Convert axis to DLT. ONNXAxis is origin 0 and we index from the end
mlAxis = numDimsX - ONNXAxis;
% Use subsref to index into data
Indices.subs = repmat({':'}, 1, numDimsX);
Indices.subs{mlAxis} = mlIdx(:);                                          % Index as a column to ensure the output is 1-D in the indexed dimension (for now).
Indices.type = '()';
Y = subsref(X, Indices);
% (2) Now do the reshaping part of Gather
shape = size(Y, 1:numDimsX);
if numDimsIdx == 0
    % Delete the indexed dimension
    shape(mlAxis) = [];
elseif numDimsIdx > 1
    % Reshape the indexed dimension into the shape of ONNXIdx
    shape = [shape(1:mlAxis-1) size(ONNXIdx, 1:numDimsIdx) shape(mlAxis+1:end)];
end
% Extend the shape to 2D so it's valid MATLAB
if numel(shape) < 2
    shape = [shape ones(1,2-numel(shape))];
end
Y = reshape(Y, shape);
end

function [D, numDimsD] = onnxMatMul(A, B, numDimsA, numDimsB)
% Implements the ONNX MatMul operator.

% If either arg is more than 2D, loop over all dimensions before the final
% 2. Inside the loop, perform matrix multiplication.

% If B is 1-D, temporarily extend it to a row vector
if numDimsB==1
    B = B(:)';
end
maxNumDims = max(numDimsA, numDimsB);
numDimsD = maxNumDims;
if maxNumDims > 2
    % sizes of matrices to be multiplied
    matSizeA        = size(A, 1:2);
    matSizeB        = size(B, 1:2);
    % size of the stack of matrices
    stackSizeA      = size(A, 3:maxNumDims);
    stackSizeB      = size(B, 3:maxNumDims);
    % final stack size
    resultStackSize = max(stackSizeA, stackSizeB);
    % full implicitly-expanded sizes
    fullSizeA       = [matSizeA resultStackSize];
    fullSizeB       = [matSizeB resultStackSize];
    resultSize      = [matSizeB(1) matSizeA(2) resultStackSize];
    % Repmat A and B up to the full stack size using implicit expansion
    A = A + zeros(fullSizeA);
    B = B + zeros(fullSizeB);
    % Reshape A and B to flatten the stack dims (all dims after the first 2)
    A2 = reshape(A, size(A,1), size(A,2), []);
    B2 = reshape(B, size(B,1), size(B,2), []);
    % Iterate down the stack dim, doing the 2d matrix multiplications
    D2 = zeros([matSizeB(1), matSizeA(2), size(A2,3)], 'like', A);
    for i = size(A2,3):-1:1
        D2(:,:,i) = B2(:,:,i) * A2(:,:,i);
    end
    % Reshape D2 to the result size (unflatten the stack dims)
    D = reshape(D2, resultSize);
else
    D = B * A;
    if numDimsA==1 || numDimsB==1
        D = D(:);
        numDimsD = 1;
    end
end
end

function [Y, numDimsY] = onnxShape(X, numDimsX)
% Implements the ONNX Shape operator
% Return the reverse ONNX shape as a 1D column vector
switch numDimsX
    case 0
        if isempty(X)
            Y = dlarray(0);
        else
            Y = dlarray(1);
        end
    case 1
        if isempty(X)
            Y = dlarray(0);
        else
            Y = dlarray(size(X,1));
        end
    otherwise
        Y = dlarray(fliplr(size(X, 1:numDimsX))');
end
numDimsY = 1;
end

function [Y, numDimsY] = onnxSqueeze(X, ONNXAxes, numDimsX)
% Implements the ONNX Squeeze operator
if numDimsX == 0
    Y = X;
    numDimsY = numDimsX;
else
    % Find the new ONNX shape
    curOShape = size(X, numDimsX:-1:1);
    if isempty(ONNXAxes)
        newOShape = curOShape(curOShape ~= 1);
    else
        ONNXAxes(ONNXAxes<0) = ONNXAxes(ONNXAxes<0) + numDimsX;
        newOShape = curOShape;
        newOShape(ONNXAxes+1) = [];
    end
    % Get numDimsY from ONNX shape
    numDimsY  = numel(newOShape);
    newMShape = [fliplr(newOShape) ones(1, 2-numDimsY)];    % Append 1's to shape if numDims<2
    Y         = reshape(X, newMShape);
end
end

function [output, numDimsOutput] = onnxWhere(condition, X, Y, numDimsCondition, numDimsX, numDimsY)
bigz = zeros(size(condition + X + Y));      % broadcast
condition = condition + bigz;
X = X + bigz;
output = Y + bigz;
output(condition==1) = X(condition==1);
numDimsOutput = max([numDimsCondition, numDimsX, numDimsY]);
end

function [DLTAxis, numDimsY] = prepareConcatArgs(ONNXAxis, numDimsXs)
% Prepares arguments for implementing the ONNX Concat operator
numDimsY = numDimsXs(1);
if ONNXAxis<0
    ONNXAxis = ONNXAxis + numDimsY;
end
DLTAxis = numDimsY - ONNXAxis;
end

function [shape, numDimsY] = prepareExpandArgs(ONNXShape)
% Prepares arguments for implementing the ONNX Expand operator

% Broadcast X to ONNXShape. The shape of X must be compatible with ONNXShape.
ONNXShape = extractdata(ONNXShape);
shape = fliplr(ONNXShape(:)');
if numel(shape) < 2
    shape = [shape ones(1, 2-numel(shape))];
end
numDimsY = numel(ONNXShape);
end

function [dim1, dim2, numDimsY] = prepareFlattenArgs(X, ONNXAxis, numDimsX)
% Prepares arguments for implementing the ONNX Flatten operator

% ONNXAxis is the number of dimensions that go on the left in ONNX, so here
% it is the number of dimensions that go on the right.
if ONNXAxis < 0
    ONNXAxis = ONNXAxis + numDimsX;
end
if ONNXAxis == 0
    dim2 = 1;
else
    dim2 = prod(size(X, numDimsX+1-ONNXAxis:numDimsX));     % numel on the right
end
dim1 = numel(X)/dim2;                                   % numel on the left
numDimsY = 2;
end

function dims = prepareReduceArgs(ONNXAxes, numDimsX)
% Prepares arguments for implementing the ONNX Reduce operator
if isempty(ONNXAxes)
    ONNXAxes = 0:numDimsX-1;   % All axes
end
ONNXAxes(ONNXAxes<0) = ONNXAxes(ONNXAxes<0) + numDimsX;
dims = numDimsX - ONNXAxes;
end

function [DLTShape, numDimsY] = prepareReshapeArgs(X, ONNXShape, numDimsX)
% Prepares arguments for implementing the ONNX Reshape operator
ONNXShape = flip(extractdata(ONNXShape));            % First flip the shape to make it correspond to the dimensions of X.
% In ONNX, 0 means "unchanged", and -1 means "infer". In DLT, there is no
% "unchanged", and [] means "infer".
DLTShape = num2cell(ONNXShape);                      % Make a cell array so we can include [].
% Replace zeros with the actual size
if any(ONNXShape==0)
    i0 = find(ONNXShape==0);
    DLTShape(i0) = num2cell(size(X, numDimsX - numel(ONNXShape) + i0));  % right-align the shape vector and dims
end
if any(ONNXShape == -1)
    % Replace -1 with []
    i = ONNXShape == -1;
    DLTShape{i} = [];
end
if numel(DLTShape)==1
    DLTShape = [DLTShape 1];
end
numDimsY = numel(ONNXShape);
end

function [S, numDimsY] = prepareSliceArgs(X, Starts, Ends, Axes, Steps, numDimsX)
% Prepares arguments for implementing the ONNX Slice operator

% Starts, Ends and Axes are all origin 0. Axes refer to the ONNX dimension
% ordering, but X uses the reverse, DLT ordering. Starts, Ends, Axes, and
% Steps correspond positionally. Axes and Steps may be omitted, with
% defaults described in the ONNX spec.

% Set default Axes and Steps if not supplied
if isempty(Axes)
    Axes = 0:numDimsX-1;   % All axes
end
Axes(Axes<0) = Axes(Axes<0) + numDimsX; % Handle negative Axes.
if isempty(Steps)
    Steps = ones(1, numel(Starts));
end
% Init all dims to :
S.subs = repmat({':'}, 1, numDimsX);
S.type = '()';
% Set Starts and Ends for each axis
for i = 1:numel(Axes)
    DLTDim = numDimsX - Axes(i);                                               % The DLT dim is the reverse of the ONNX dim.
    % "If a negative value is passed for any of the start or end indices,
    % it represents number of elements before the end of that dimension."
    if Starts(i) < 0
        Starts(i) = size(X,DLTDim) + Starts(i);
    end
    if Ends(i) < 0
        Ends(i) = max(-1, size(X,DLTDim) + Ends(i));                        % The -1 case is when we're slicing backward and want to include 0.
    end
    % "If the value passed to start or end is larger than the n (the number
    % of elements in this dimension), it represents n."
    if Starts(i) > size(X,DLTDim)
        Starts(i) = size(X,DLTDim);
    end
    if Ends(i) > size(X,DLTDim)
        Ends(i) = size(X,DLTDim);
    end
    if Steps(i) > 0
        S.subs{DLTDim} = 1 + (Starts(i) : Steps(i) : Ends(i)-1);            % 1 + (Origin 0 indexing with end index excluded)
    else
        S.subs{DLTDim} = 1 + (Starts(i) : Steps(i) : Ends(i)+1);            % 1 + (Origin 0 indexing with end index excluded)
    end
end
numDimsY = numDimsX;
end

function [perm, numDimsA] = prepareTransposeArgs(ONNXPerm, numDimsA)
% Prepares arguments for implementing the ONNX Transpose operator
if numDimsA <= 1        % Tensors of numDims 0 or 1 are unchanged by ONNX Transpose.
    perm = [];
else
    if isempty(ONNXPerm)        % Empty ONNXPerm means reverse the dimensions.
        perm = numDimsA:-1:1;
    else
        perm = numDimsA-flip(ONNXPerm);
    end
end
end

function [newShape, numDimsY] = prepareUnsqueezeArgs(X, ONNXAxes, numDimsX)
% Prepares arguments for implementing the ONNX Unsqueeze operator

% ONNX axes are origin 0
ONNXAxes = extractdata(ONNXAxes);
ONNXAxes(ONNXAxes<0) = ONNXAxes(ONNXAxes<0) + numDimsX;
ONNXAxes = sort(ONNXAxes);                                              % increasing order
numDimsY = numDimsX + numel(ONNXAxes);
if numDimsY == 1
    newShape = size(X);
else
    DLTAxes  = flip(numDimsY - ONNXAxes);                                  % increasing order
    newShape = ones(1, numDimsY);
    posToSet = setdiff(1:numDimsY, DLTAxes, 'stable');
    newShape(posToSet) = size(X, 1:numel(posToSet));
end
end

%% Utility functions:

function s = appendStructs(varargin)
% s = appendStructs(s1, s2,...). Assign all fields in s1, s2,... into s.
if isempty(varargin)
    s = struct;
else
    s = varargin{1};
    for i = 2:numel(varargin)
        fromstr = varargin{i};
        fs = fieldnames(fromstr);
        for j = 1:numel(fs)
            s.(fs{j}) = fromstr.(fs{j});
        end
    end
end
end

function checkInputSize(inputShape, expectedShape, inputName)

if numel(expectedShape)==0
    % The input is a scalar
    if ~isequal(inputShape, [1 1])
        inputSizeStr = makeSizeString(inputShape);
        error(message('nnet_cnn_onnx:onnx:InputNeedsResize',inputName, "[1,1]", inputSizeStr));
    end
elseif numel(expectedShape)==1
    % The input is a vector
    if ~shapeIsColumnVector(inputShape) || ~iSizesMatch({inputShape(1)}, expectedShape)
        expectedShape{2} = 1;
        expectedSizeStr = makeSizeString(expectedShape);
        inputSizeStr = makeSizeString(inputShape);
        error(message('nnet_cnn_onnx:onnx:InputNeedsResize',inputName, expectedSizeStr, inputSizeStr));
    end
else
    % The input has 2 dimensions or more
    
    % The input dimensions have been reversed; flip them back to compare to the
    % expected ONNX shape.
    inputShape = fliplr(inputShape);
    
    % If the expected shape has fewer dims than the input shape, error.
    if numel(expectedShape) < numel(inputShape)
        expectedSizeStr = strjoin(["[", strjoin(string(expectedShape), ","), "]"], "");
        error(message('nnet_cnn_onnx:onnx:InputHasGreaterNDims', inputName, expectedSizeStr));
    end
    
    % Prepad the input shape with trailing ones up to the number of elements in
    % expectedShape
    inputShape = num2cell([ones(1, numel(expectedShape) - length(inputShape)) inputShape]);
    
    % Find the number of variable size dimensions in the expected shape
    numVariableInputs = sum(cellfun(@(x) isa(x, 'char') || isa(x, 'string'), expectedShape));
    
    % Find the number of input dimensions that are not in the expected shape
    % and cannot be represented by a variable dimension
    nonMatchingInputDims = setdiff(string(inputShape), string(expectedShape));
    numNonMatchingInputDims  = numel(nonMatchingInputDims) - numVariableInputs;
    
    expectedSizeStr = makeSizeString(expectedShape);
    inputSizeStr = makeSizeString(inputShape);
    if numNonMatchingInputDims == 0 && ~iSizesMatch(inputShape, expectedShape)
        % The actual and expected input dimensions match, but in
        % a different order. The input needs to be permuted.
        error(message('nnet_cnn_onnx:onnx:InputNeedsPermute',inputName, expectedSizeStr, inputSizeStr));
    elseif numNonMatchingInputDims > 0
        % The actual and expected input sizes do not match.
        error(message('nnet_cnn_onnx:onnx:InputNeedsResize',inputName, expectedSizeStr, inputSizeStr));
    end
end
end

function doesMatch = iSizesMatch(inputShape, expectedShape)
% Check whether the input and expected shapes match, in order.
% Size elements match if (1) the elements are equal, or (2) the expected
% size element is a variable (represented by a character vector or string)
doesMatch = true;
for i=1:numel(inputShape)
    if ~(isequal(inputShape{i},expectedShape{i}) || ischar(expectedShape{i}) || isstring(expectedShape{i}))
        doesMatch = false;
        return
    end
end
end

function sizeStr = makeSizeString(shape)
sizeStr = strjoin(["[", strjoin(string(shape), ","), "]"], "");
end

function isVec = shapeIsColumnVector(shape)
if numel(shape) == 2 && shape(2) == 1
    isVec = true;
else
    isVec = false;
end
end
function X = makeUnlabeledDlarray(X)
% Make numeric X into an unlabelled dlarray
if isa(X, 'dlarray')
    X = stripdims(X);
elseif isnumeric(X)
    if ~(isa(X,'single') || isa(X,'double'))
        % Make ints double so they can combine with anything without
        % reducting precision
        X = double(X);
    end
    X = dlarray(X);
end
end

function [Vars, NumDims] = packageVariables(params, inputNames, inputValues, inputNumDims)
% inputNames, inputValues are cell arrays. inputRanks is a numeric vector.
Vars = appendStructs(params.Learnables, params.Nonlearnables, params.State);
NumDims = params.NumDimensions;
% Add graph inputs
for i = 1:numel(inputNames)
    Vars.(inputNames{i}) = inputValues{i};
    NumDims.(inputNames{i}) = inputNumDims(i);
end
end

function X = permuteInputVar(X, userDataPerm, onnxNDims)
% Returns reverse-ONNX ordering
if onnxNDims == 0
    return;
elseif onnxNDims == 1 && isvector(X)
    X = X(:);
    return;
elseif isnumeric(userDataPerm)
    % Permute into reverse ONNX ordering
    perm = fliplr(userDataPerm);
elseif isequal(userDataPerm, 'auto') && onnxNDims == 4
    % Permute MATLAB HWCN to reverse onnx (WHCN)
    perm = [2 1 3 4];
else
    % userDataPerm is either 'none' or 'auto' with no default, which means
    % it's already in onnx ordering, so just make it reverse onnx
    perm = max(2,onnxNDims):-1:1;
end
X = permute(X, perm);
end
function Y = permuteOutputVar(Y, userDataPerm, onnxNDims)
switch onnxNDims
    case 0
        perm = [];
    case 1
        if isnumeric(userDataPerm)
            % Use the user's permutation because Y is a column vector which
            % already matches ONNX.
            perm = userDataPerm;
        elseif isequal(userDataPerm, 'auto')
            % Treat the 1D onnx vector as a 2D column and transpose it
            perm = [2 1];
        else
            % userDataPerm is 'none'. Leave Y alone because it already
            % matches onnx.
            perm = [];
        end
    otherwise
        % ndims >= 2
        if isnumeric(userDataPerm)
            % Use the inverse of the user's permutation. This is not just the
            % flip of the permutation vector.
            perm = onnxNDims + 1 - userDataPerm;
        elseif isequal(userDataPerm, 'auto')
            if onnxNDims == 2
                % Permute reverse ONNX CN to DLT CN (do nothing)
                perm = [];
            elseif onnxNDims == 4
                % Permute reverse onnx (WHCN) to MATLAB HWCN
                perm = [2 1 3 4];
            else
                % User wants the output in ONNX ordering, so just reverse it from
                % reverse onnx
                perm = onnxNDims:-1:1;
            end
        else
            % userDataPerm is 'none', so just make it reverse onnx
            perm = onnxNDims:-1:1;
        end
end
if ~isempty(perm)
    Y = permute(Y, perm);
end
end

function s = updateStruct(s, t)
% Set all existing fields in s from fields in t, ignoring extra fields in t.
for name = transpose(fieldnames(s))
    s.(name{1}) = t.(name{1});
end
end
